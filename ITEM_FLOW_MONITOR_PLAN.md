# Item Flow Monitor — План реализации мода

## Описание проекта

Мод для Minecraft (Fabric) добавляет возможность отслеживать поток предметов в контейнерах. При открытии контейнера в GUI появляется кнопка, через которую можно выбрать предмет для отслеживания, период и режим расчёта. Компактный счётчик в углу интерфейса показывает, сколько выбранных предметов поступило за выбранный период. Никаких новых блоков — только UI поверх стандартных контейнеров.

**Стек:** Fabric + Fabric API, Minecraft 1.21.11, Java 21, Mixin, Mojang Mappings.

---

## Этап 0: Инициализация проекта ✅ DONE

### 0.1 — Генерация проекта из Fabric template ✅ DONE

Создать проект из шаблона Fabric mod. Настроить `fabric.mod.json`, `build.gradle`, группу и ID мода (`itemflowmonitor`).

**Результат:** Проект создан из `fabric-example-mod`. Версии: MC 1.21.11, Fabric Loader 0.18.4, Fabric API 0.141.2, Loom 1.14. `./gradlew build` — SUCCESS. Jar скопирован в инстанс `ModDevelop`.

**Тест:** ✅ Инстанс запущен. В логах: `Loading 49 mods: ... itemflowmonitor 0.1.0`. Сообщение `Item Flow Monitor загружен!` в консоли. Мир создан и загружен без ошибок.

### 0.2 — Структура пакетов ✅ DONE

Создать пакеты:
- `com.itemflowmonitor` — точка входа
- `com.itemflowmonitor.client` — клиентская часть (GUI, рендер)
- `com.itemflowmonitor.mixin` — серверные миксины
- `com.itemflowmonitor.mixin.client` — клиентские миксины

(Пакеты `tracker`, `network`, `util` добавлены по ходу реализации)

**Результат:** `./gradlew build` — SUCCESS.

---

## Этап 1: Кнопка в интерфейсе сундука ✅ DONE

### 1.1 + 1.2 — Кнопка IFM в экране сундука ✅ DONE (объединены)

Использован Fabric Screen API (`ScreenEvents.AFTER_INIT`) вместо Mixin — более надёжный подход. При открытии `ContainerScreen` добавляется кнопка "IFM" справа от GUI. Access Widener для доступа к `leftPos`, `topPos`, `imageWidth`. По нажатию — сообщение в чат.

**Результат:** `./gradlew build` — SUCCESS. Jar скопирован.

**Тест:** ✅ Кнопка видна справа от GUI сундука. Нажатие — сообщение в чат. Работает при повторном открытии.

### 1.3 — Кнопка отображается только на контейнерах ✅ DONE

Кнопка привязана к `ContainerScreen`, поэтому появляется только на контейнерах. Бочка тоже использует `ContainerScreen` — это ожидаемо и полезно для будущей поддержки (этап 6).

**Тест:** ✅ Сундук ✅, двойной сундук ✅, бочка ✅ (бонус), инвентарь ❌, верстак ❌.

---

## Этап 2: Панель настроек отслеживания ✅ DONE

### 2.1 — Открытие панели по кнопке ✅ DONE

Кастомный виджет `SettingsPanel` (extends `AbstractWidget`) рисуется поверх GUI контейнера. Toggle по кнопке IFM — показ/скрытие через `Screens.getButtons()`.

**Тест:** ✅ Панель появляется/скрывается по нажатию IFM.

### 2.2 — Выбор периода ✅ DONE

3 кнопки: `/sec`, `/min`, `/hour`. Выбранный подсвечен зелёным. По умолчанию `/min`. (Период `/tick` удалён как бесполезный.)

**Тест:** ✅ Переключение работает, подсветка корректна.

### 2.3 — Режим выбора предмета: "Все", "Авто", "Вручную" ✅ DONE

3 кнопки: `All`, `Auto`, `Manual`. Выбранный подсвечен зелёным. По умолчанию `All`. "Manual" пока без функционала выбора предмета (будет в 2.4).

**Тест:** ✅ Переключение работает, панель отображается корректно (ширина 140px).

### 2.4 — Ручной выбор предмета из содержимого сундука ✅ DONE

В режиме "Вручную" — показать список предметов, которые сейчас лежат в сундуке (иконка + название). Клик по предмету выбирает его для отслеживания. Выбранный предмет отображается на панели.

**Результат:** Панель получает меню контейнера через `screen.getMenu()`. В режиме MANUAL — сканируются уникальные предметы (без инвентаря игрока через `slot.container instanceof Inventory`). Список: иконка 16x16 + название. Клик — выбор (зелёная подсветка), повторный клик — снятие. Панель динамически растёт. До 6 предметов видимых, остальные — "+N more...".

**Тест:** ✅ Подтверждено пользователем.

### 2.5 — Тумблер включения/выключения трекинга ✅ DONE

Toggle ON/OFF на панели. По умолчанию OFF. Когда OFF — секции настроек скрыты (компактная панель). Когда ON — полная панель. Выключение отправляет `active=false` на сервер, удаляя трекер.

**Тест:** ✅ Подтверждено пользователем.

### 2.6 — Режим расчёта rate ✅ DONE

3 кнопки: `Actual`, `Predict`, `Average`.
- **Actual** — фактическое количество за скользящее окно периода.
- **Predict** — экстраполяция из 10-секундного окна + EMA-сглаживание (alpha=0.05). Быстрая реакция.
- **Average** — среднее с момента старта/Reset: `totalItems / elapsedTicks * periodTicks`. Стабильная средняя производительность для ферм.

**Результат:** `RateMode` enum. В `ContainerTracker`: PREDICTED с EMA + округлением, AVERAGE с `startTick`. Пакеты и сериализация обновлены (backward-compatible через `optionalFieldOf`).

**Тест:** ✅ Подтверждено пользователем. Воронка стабильно показывает 150/min в Predict.

### 2.7 — Кнопка Reset ✅ DONE

Кнопка "Reset" на строке заголовка панели (красная при наведении). Сбрасывает буфер событий, EMA-сглаживание и startTick. Сигнал: `modeOrdinal=-2`.

**Тест:** ✅ Подтверждено пользователем.

---

## Этап 3: Серверная логика — отслеживание поступления предметов ✅ DONE

### 3.1 — Структура данных TrackerData ✅ DONE

**Результат:** `tracker/ContainerTracker.java` — привязка к BlockPos, режим, предмет, период, rateMode, кольцевой буфер `LinkedList<ItemEvent>` с авто-очисткой (>72000 тиков). Методы: `recordEvent()`, `getRate()`, `clearEvents()`. EMA-сглаживание для PREDICTED, cumulative average для AVERAGE.

### 3.2 — Глобальный реестр трекеров TrackerManager ✅ DONE

**Результат:** `tracker/TrackerManager.java` — синглтон с `Map<BlockPos, ContainerTracker>`. Методы: `getOrCreate()`, `getTracker()`, `remove()`, `hasTracker()`, `clear()`.

### 3.3 — Mixin: перехват вставки предмета в контейнер ✅ DONE

**Результат:** `mixin/HopperBlockEntityMixin.java` — хук в `addItem(Container, Container, ItemStack, Direction)`. ThreadLocal для сохранения оригинального стека. Поддержка одинарных контейнеров (`BlockEntity`) и двойных сундуков (`CompoundContainer` с нормализацией через `ChestUtil`). Debug-команды `/ifm track|info|remove`.

**Тест:** ✅ Одинарный сундук: 150 items/min (корректно для хоппера). Двойной сундук: работает с каноническими позициями.

### 3.4 — Режим "Авто": привязка к первому предмету ✅ DONE

**Результат:** Встроено в `ContainerTracker.recordEvent()` — при `mode == AUTO && trackedItem == null` фиксирует `item` из первого события.

---

## Этап 4: Подсчёт и отображение rates ✅ DONE

### 4.1–4.4 — Networking + Rate overlay ✅ DONE

**Результат:** Полная сетевая интеграция:
- `network/TrackerConfigC2SPacket.java` — C2S пакет (pos, active, modeOrdinal, periodOrdinal, rateModeOrdinal, itemId). Сигналы: -1=subscribe, -2=reset.
- `network/TrackerUpdateS2CPacket.java` — S2C пакет (pos, active, rate, modeOrdinal, periodOrdinal, rateModeOrdinal, trackedItemId)
- `network/TrackerNetworking.java` — серверная обработка + тик (каждый тик для мгновенного обновления)
- `client/TrackerClientState.java` — клиентский кеш по BlockPos с `removeFromCache()`
- `ItemFlowMonitorClient.java` — обработка S2C, кнопка IFM, rate overlay, deferred focus removal
- `SettingsPanel.java` — callback `onSettingsChanged` и `onReset` для отправки C2S
- `TrackerManager.java` — отслеживание viewer'ов (UUID → BlockPos)

Rate overlay: иконка предмета + значение + период в правом верхнем углу GUI. Epsilon-проверка для целочисленного отображения (0 вместо 0.0).

**Тест:** ✅ Подтверждено пользователем.

---

## Этап 5: Полировка и edge cases ✅ DONE

### 5.1 — Сохранение настроек трекера при перезаходе ✅ DONE

**Результат:** `tracker/TrackerSavedData.java` — сериализация через Mojang `Codec` с `RecordCodecBuilder`. `TrackerEntry` (pos, mode, period, rateMode, itemId). `optionalFieldOf("rateMode", 0)` для backward compatibility. Загрузка при `SERVER_STARTED`, автосохранение через `markDirtyIfLoaded()`.

**Тест:** ✅ Настройки трекеров сохраняются между перезаходами. Rate начинает считать заново (буфер не сохраняется).

### 5.2 — Удаление трекера при разрушении контейнера ✅ DONE

**Результат:** `PlayerBlockBreakEvents.AFTER` в `ItemFlowMonitor.onInitialize()`. Использует old `BlockState` для определения типа сундука. Для двойных сундуков — проверяет обе половины и удаляет трекер. `TrackerSavedData.markDirtyIfLoaded()` для сохранения.

**Тест:** ✅ Подтверждено пользователем. Сломать сундук с трекером → трекер удаляется. Новый сундук на том же месте — чист.

### 5.3 — Двойной сундук ✅ DONE

**Результат:** `util/ChestUtil.java` — нормализация позиции двойного сундука к «каноническому» блоку (меньшие координаты). Два метода: `getCanonicalPos(Level, BlockPos)` для клиента, `getCanonicalPosFromCompound(CompoundContainer)` для мixin. Клиент нормализует при `captureContainerPos()`, мixin нормализует при записи событий.

**Тест:** ✅ Подтверждено пользователем. Двойной сундук — одна панель, один трекер, один счётчик.

### 5.4 — Кнопка сброса счётчика ✅ DONE

**Результат:** Кнопка "Reset" на панели, сигнал `modeOrdinal=-2` на сервер. Сервер вызывает `tracker.clearEvents()` + отправляет обновление. Сбрасывает буфер, EMA и startTick.

**Тест:** ✅ Подтверждено пользователем.

### 5.5 — Визуальная индикация активного трекера — SKIPPED

Решено пропустить. Не критично для функциональности.

---

## Этап 6: Поддержка всех контейнеров ✅ DONE

### 6.1 — Абстракция ITrackableContainer — SKIPPED (не нужна)

Текущая архитектура уже поддерживает все контейнеры без абстракции:
- Экран: Fabric Screen API с whitelist `isStorageScreen()` — работает на любом `AbstractContainerScreen`
- Трекинг: Mixin на `HopperBlockEntity.addItem()` перехватывает передачу в **любой** контейнер

### 6.2 + 6.3 — Все контейнеры-хранилища ✅ DONE (объединены)

**Результат:** Рефакторинг `ItemFlowMonitorClient` — все методы работают с `AbstractContainerScreen<?>`. Whitelist поддерживаемых экранов:
- `ContainerScreen` — сундук (одинарный/двойной), бочка, эндер-сундук
- `ShulkerBoxScreen` — шулкер-бокс
- `HopperScreen` — воронка (считает только входящие, исходящие идут в dest другого контейнера)
- `DispenserScreen` — раздатчик, выбрасыватель

**Тест:** ✅ Подтверждено пользователем. Кнопка IFM и трекинг работают на всех контейнерах.

---

## Этап 7: Печки и коптильни ✅ DONE

### 7.1 — Добавить AbstractFurnaceScreen в whitelist ✅ DONE

**Результат:** В `isStorageScreen()` добавлены проверки: `SmokerScreen` → `BlastFurnaceScreen` → `AbstractFurnaceScreen` (fallback для обычной печки). Каждый тип привязан к своему ключу конфига. Порядок `instanceof` важен — конкретные наследники до базового класса.

**Файлы:** `ItemFlowMonitorClient.java` — строки 110–119.

**Тест:** ✅ Подтверждено пользователем. Печка, коптильня, доменная печь — кнопка IFM видна, трекинг работает.

---

## Этап 8: Настройки через Mod Menu ✅ DONE

### 8.1 — Конфиг-файл (JSON) ✅ DONE

**Результат:** `IFMConfig.java` — singleton с lazy-load, сериализация через Gson. 9 типов контейнеров. Дефолт: все `true` кроме `ender_chest: false`. Мерж дефолтов + файла при загрузке (новые ключи подхватываются автоматически).

**Файлы:** `src/client/java/com/itemflowmonitor/config/IFMConfig.java`

**Тест:** ✅ Файл `config/itemflowmonitor.json` создаётся с дефолтами. Эндер-сундук без кнопки. Ручное изменение + перезапуск — работает.

### 8.2 — Экран настроек (Config Screen) ✅ DONE

**Результат:** `IFMConfigScreen` — кастомный `Screen` с 9 toggle-кнопками ON/OFF + кнопка Done. Лейблы слева, кнопки справа. Done сохраняет, Esc отменяет.

**Баг-фиксы при ревью:**
- Цвета `drawString`/`drawCenteredString` были в RGB (`0xFFFFFF`) вместо ARGB (`0xFFFFFFFF`) — текст мог быть невидимым в MC 1.21.6+. Исправлено.
- Лейбл "Dispenser / Dropper" налезал на кнопку ON/OFF. Увеличено расстояние: лейблы `centerX-80`, кнопки `centerX+55`.

**Файлы:** `src/client/java/com/itemflowmonitor/config/IFMConfigScreen.java`

**Тест:** ✅ Все чекбоксы видны, текст читаемый, toggle работает, настройки сохраняются через Done.

### 8.3 — Интеграция с Mod Menu ✅ DONE

**Результат:** `ModMenuIntegration` implements `ModMenuApi`, фабрика для `IFMConfigScreen`. Зависимость `modImplementation` в build.gradle (доступна при компиляции и в dev-среде, не включается в финальный jar). Entrypoint `"modmenu"` в `fabric.mod.json`, `"modmenu": "*"` в `suggests`.

**Файлы:** `ModMenuIntegration.java`, `build.gradle`, `fabric.mod.json`

**Тест:** ✅ Шестерёнка в Mod Menu → экран настроек открывается.

### 8.4 — Интеграция конфига в isStorageScreen() ✅ DONE

**Результат:** `isStorageScreen()` проверяет `IFMConfig.getInstance().isContainerEnabled()` для каждого типа экрана. `ContainerScreen` (сундук/бочка/эндер-сундук) разделяется через `getContainerScreenConfigKey()` по блоку из hitResult.

**Файлы:** `ItemFlowMonitorClient.java` — `isStorageScreen()`, `getContainerScreenConfigKey()`

**Тест:** ✅ Полный цикл: Mod Menu → выключить бочку → сохранить → бочка без кнопки → вернуть → кнопка есть.

---

## Этап 9: Тултипы (подсказки) ✅ DONE

### 9.1 — Система тултипов в SettingsPanel ✅ DONE

**Результат:** Используется MC API `GuiGraphics.setComponentTooltipForNextFrame()` — тултип рендерится фреймворком с автоматическим позиционированием и z-order. Задержка **500ms** (научно обоснована: NNG рекомендует 300–500ms, Windows default 400ms, macOS ~500ms). Логика: `hoveredElementId` определяется в `renderWidget()`, `renderTooltip()` сравнивает с `lastHoveredElement` и отслеживает `hoverStartTimeMs`.

**Файлы:** `SettingsPanel.java` — поля `lastHoveredElement`, `hoverStartTimeMs`, `TOOLTIP_DELAY_MS`; методы `getTooltipForElement()`, `renderTooltip()`.

**Тест:** ✅ Подтверждено пользователем.

### 9.2 — Тултипы для всех элементов панели ✅ DONE

**Результат:** Многострочные тултипы (через `List<Component>`) для rate modes с примерами. Тултип кнопки IFM через `Button.tooltip()` + `setTooltipDelay(500ms)`.

Тексты тултипов (hardcoded English, будут заменены на `Component.translatable()` в этапе 10):
- **Toggle ON/OFF:** "Enable/Disable item tracking for this container"
- **Period /sec|/min|/hour:** "Count items per second/minute/hour"
- **Average (3 строки):** "Average: total items ÷ total time" + пример + "Stable value, good for long-term monitoring"
- **Actual (3 строки):** "Actual: exact count in current time window" + пример + "Resets to 0 at the start of each period"
- **Predicted (3 строки):** "Predicted: estimates full rate from last 10 sec" + пример + "Updates in real-time, reacts to speed changes"
- **Mode All:** "Track all items entering this container"
- **Mode Auto:** "Automatically track the first item type detected"
- **Mode Manual (2 строки):** "Track only one item type" + "Choose from items currently in this container"
- **Reset:** "Clear all recorded data and start fresh"
- **Item list entries:** Полное название предмета (только если обрезано)
- **Кнопка IFM:** "Item Flow Monitor — track items passing through this container"

**Решение:** Порядок RateMode изменён на AVERAGE → ACTUAL → PREDICTED (Average по умолчанию, на первом месте). Ordinal'ы поменялись — несовместимо с ранее сохранёнными данными (мод в разработке, некритично).

**Файлы:** `SettingsPanel.java`, `ItemFlowMonitorClient.java`, `RateMode.java`

**Тест:** ✅ Подтверждено пользователем.

---

## Этап 10: Локализация (i18n) ✅ DONE

### 10.1 + 10.2 — Вынести все строки в lang-файлы + en_us ✅ DONE (объединены)

**Результат:** Все хардкод-строки заменены на `Component.translatable()`:
- `SettingsPanel.java` — заголовок, кнопки (Reset, ON/OFF), лейблы (Period, Rate, Mode, Select item), тултипы, пустой контейнер, "+N more..."
- `IFMConfigScreen.java` — заголовок, подзаголовок, кнопка Done, ON/OFF, названия контейнеров
- `ItemFlowMonitorClient.java` — кнопка IFM, тултип кнопки, rate overlay (period label)
- Enum'ы (`RateMode`, `TrackingMode`, `TrackingPeriod`) — добавлены `translationKey`, `getTranslationKey()`, `getComponent()`. `getLabel()` сохранён для серверных debug-команд.

**Файл:** `src/main/resources/assets/itemflowmonitor/lang/en_us.json` — 57 ключей.

**Тест:** `./gradlew build` — SUCCESS.

### 10.3 — Русский: ru_ru ✅ DONE

**Файл:** `src/main/resources/assets/itemflowmonitor/lang/ru_ru.json`

**Тест:** `./gradlew build` — SUCCESS.

### 10.4 — Дополнительные языки ✅ DONE

12 языков: en_us, ru_ru, zh_cn, zh_tw, de_de, fr_fr, es_es, pt_br, ja_jp, ko_kr, uk_ua, pl_pl.

**Файлы:** `src/main/resources/assets/itemflowmonitor/lang/*.json`

**Тест:** `./gradlew build` — SUCCESS. Jar скопирован в тестовый инстанс.

---

## Этап 11: Оптимизация и качество кода

### 11.1 — Оптимизация сетевых пакетов ✅ DONE

Сейчас S2C пакет отправляется каждый тик. Оптимизация: отправлять только при изменении rate (delta > 0.01) или раз в 20 тиков (1 сек fallback). Экономия трафика ~95%.

**Результат:** Delta-check + fallback interval в `tick()`. Группировка viewer'ов по BlockPos — один расчёт на контейнер. Кеш `CachedState` per-BlockPos. Вынос построения пакета в `buildUpdatePacket()`. Очистка кеша при удалении трекера и остановке сервера.

**Файлы:** `TrackerNetworking.java`, `ItemFlowMonitor.java`.

**Тест:** ✅ Подтверждено пользователем.

### 11.2 — Форматирование больших чисел ✅ DONE

Для rate >= 10000: компактный формат "15K", "1.5M". До 10K — полное число.

**Результат:** Метод `formatRate()` в `ItemFlowMonitorClient`. Пороги: >=1M → "1.5M"/"15M", >=10K → "15K"/"100K", >=10 → целое, <10 → одна десятая.

**Файлы:** `ItemFlowMonitorClient.java` — `formatRate()`.

**Тест:** ✅ Подтверждено пользователем.

### 11.3 — Цветовая индикация rate ✅ DONE

Цвет числа rate в overlay зависит от потока:
- Белый (`0xFFFFFFFF`) — предметы поступают (rate > 0)
- Тёмно-серый (`0xFF555555`) — нет потока (rate == 0)

Жёлтый цвет ("мало предметов") убран — субъективный порог, бесполезен при наличии числового значения.

**Файлы:** `ItemFlowMonitorClient.java` — `renderRateOverlay()`.

**Тест:** Активный поток → светлый текст. Остановить поток → серый текст.

### 11.4 — Очистка и рефакторинг ✅ DONE

- **Удалены debug-команды `/ifm track|info|remove` полностью.** Метод `registerCommands()` и неиспользуемые импорты удалены из `ItemFlowMonitor.java`.
- **Ревизия TODO/FIXME** — ни одного не найдено в коде.
- **Проверка утечек памяти** — `TrackerClientState.clearCache()` вызывается при `DISCONNECT`. Утечек нет.
- **Валидация itemId** — try-catch для `Identifier.parse()`, ограничение длины 256 символов.

**Файлы:** `ItemFlowMonitor.java`, `TrackerNetworking.java`.

**Тест:** ✅ Build SUCCESS. `/ifm` больше не регистрируется.

### 11.5 — Защита от ghost-трекеров ✅ DONE

**Результат:** Механизм паузы ghost-трекеров:
- `ContainerTracker`: добавлены `lastViewerTick`, `paused`, метод `markViewerActive()` (обновляет таймер + снимает паузу)
- `TrackerNetworking`: ghost-check каждые 200 тиков (10 сек) — если нет viewer'ов > 6000 тиков (5 мин) → пауза + очистка буфера
- `HopperBlockEntityMixin`: `!tracker.isPaused()` проверка — приостановленные трекеры не записывают события
- `ServerPlayConnectionEvents.DISCONNECT` handler — немедленная очистка viewer'а
- При подписке/настройках — `markViewerActive()` снимает паузу
- При загрузке из save — `lastViewerTick = currentGameTime` (отсчёт ghost-таймера с момента загрузки)

**Файлы:** `ContainerTracker.java`, `TrackerNetworking.java`, `HopperBlockEntityMixin.java`, `TrackerSavedData.java`.

**Тест:** ✅ Build SUCCESS.

### 11.6 — Ревизия логирования ✅ DONE

**Результат:** Аудит всех 15 вызовов LOGGER + проверка System.out/err (нет).
- **info → debug:** `TrackerSavedData` (загрузка трекеров), `ItemFlowMonitorClient` (инициализация клиента), `IFMConfig` (загрузка/сохранение конфига)
- **Оставлен 1 info:** `ItemFlowMonitor.java` — "Item Flow Monitor загружен!" (инициализация мода)
- **warn/error:** корректны (ошибка чтения конфига, ошибка сохранения конфига)
- **debug:** все вне hot path (по действиям игрока, при сохранении мира)
- **System.out/err:** отсутствуют
- **Mixin hot path:** никаких логов

**Файлы:** `ItemFlowMonitorClient.java`, `TrackerSavedData.java`, `IFMConfig.java`.

### 11.7 — Баг: разрушение половины двойного сундука теряет трекер ✅ DONE

**Результат:** При разрушении половины двойного сундука трекер **переносится** на оставшуюся половину вместо удаления.
- `TrackerManager.moveTracker(from, to)` — перемещает трекер между позициями (обновляет Map + pos объекта)
- `ContainerTracker.pos` → non-final + package-private `setPos()`
- Обработчик `PlayerBlockBreakEvents.AFTER` переписан: для двойного сундука — moveTracker, для остальных контейнеров — remove
- Если трекер на не-сломанной половине — ничего не делаем (уже корректно)

**Файлы:** `ItemFlowMonitor.java`, `TrackerManager.java`, `ContainerTracker.java`.

**Тест:** Build SUCCESS. Тест-кейсы:
1. Двойной сундук с трекером → сломать каноническую половину → трекер перенесён на вторую
2. Сломать НЕ-каноническую → трекер остаётся
3. Сломать обе → трекер удаляется
4. Открыть оставшийся одинарный → панель показывает сохранённые настройки

---

## Этап 12: Надёжность, безопасность и тестирование ✅ DONE

> **⚠️ ВАЖНО ДЛЯ АГЕНТА:** Этот этап — критический. Здесь упор на **безопасность, защитное программирование и проверку граничных случаев**. Принцип: мод **не должен навредить пользователю** ни при каких обстоятельствах. Ни крашами, ни потерей данных мира, ни лагами сервера, ни уязвимостями в мультиплеере.
>
> **Подход к реализации каждого пункта:**
> 1. Сначала **исследовать** текущее поведение — прочитать код, понять что происходит сейчас.
> 2. Думать как **злонамеренный пользователь**: что будет если отправить мусорные пакеты? Если спамить трекерами? Если вызвать race condition?
> 3. Думать как **невезучий пользователь**: что будет если крэш во время сохранения? Если мод удалён? Если файл данных повреждён?
> 4. Каждая проверка/валидация должна **fail gracefully**: логировать проблему, продолжить работу. Никогда не крашить сервер, не ломать мир, не терять предметы.
> 5. После каждого изменения — `./gradlew build` + конкретный тест-кейс. Не считать задачу выполненной без проверки.
>
> **Приоритет:** Безопасность > Производительность > Удобство. Если сомневаешься — выбирай более защитный вариант.

### 12.1 — Безопасность миксина HopperBlockEntityMixin ✅ DONE

Миксин на `addItem()` — **самое опасное место в моде**. Этот метод вызывается каждый раз когда воронка передаёт предмет. Необработанное исключение внутри может остановить передачу предмета или крашнуть тик сервера. Это единственное место где мод вмешивается в vanilla-логику — ошибка здесь может сломать игру.

**Требования:**
- **Весь код в миксине обёрнут в `try-catch(Exception e)`.** Любое исключение — ловим, логируем WARN (с rate-limit, не чаще 1 раза в 60 секунд чтобы не спамить), продолжаем работу. Миксин **никогда** не должен пробросить исключение наружу.
- Миксин **только наблюдает**: не модифицирует `ItemStack`, не меняет `return value`, не отменяет операцию `addItem()`. Проверить что `@Inject` с `at = RETURN` или `HEAD` не использует `CallbackInfoReturnable.setReturnValue()`.
- Проверить что ThreadLocal корректно очищается в `finally`-блоке (утечка ThreadLocal — труднодиагностируемый баг).
- Минимальный код в миксине: определить позицию → проверить `hasTracker()` → если нет, выйти сразу → если есть, записать событие. Никакой тяжёлой логики.

**Файлы:** `mixin/HopperBlockEntityMixin.java`.

**Тест:**
1. Намеренно сломать что-нибудь в коде трекера (в dev-среде) → миксин ловит исключение, воронка продолжает передавать предметы.
2. 200 воронок в мире, 0 трекеров → убедиться что overhead миксина минимален (одна проверка `hasTracker` и выход).
3. Проверить что `ItemStack` до и после миксина идентичен (count, NBT).

### 12.2 — Валидация BlockPos в C2S пакетах ✅ DONE

Сейчас клиент отправляет любой `BlockPos` в `TrackerConfigC2SPacket`. Злонамеренный клиент может спамить трекерами на произвольные координаты (OOM, лаг сервера). **Никогда не доверять данным от клиента.**

Проверки (все — на серверной стороне):

- Блок должен быть в **загруженном чанке** (`level.isLoaded(pos)`).
- Блок должен быть в **радиусе взаимодействия игрока** (~6 блоков, `player.canInteractWithBlock(pos, 1.0)` или ручной расчёт `distanceSqr`).
- Блок по указанным координатам должен быть **контейнером** (instanceof `BaseContainerBlockEntity` или аналог).
- Валидация `modeOrdinal`, `periodOrdinal`, `rateModeOrdinal` — должны быть в допустимых диапазонах enum'ов. Невалидное значение → игнорировать пакет.
- Валидация `itemId` — не null, не пустая строка длиннее 256 символов, соответствует формату `namespace:path`.
- При невалидном пакете — игнорировать (не крашить, не кикать). Логировать на уровне WARN (с rate-limit).

**Файлы:** `TrackerNetworking.java` — обработчик C2S пакета.

**Тест:**
1. Нормальное использование — трекер создаётся как обычно.
2. (Если возможно симулировать) Отправить BlockPos на 1000 блоков от игрока → сервер игнорирует.
3. Отправить BlockPos в выгруженном чанке → сервер игнорирует.
4. Отправить BlockPos на блок земли → сервер игнорирует.

### 12.3 — Лимит трекеров на игрока ✅ DONE

Без лимита один игрок может создать тысячи трекеров и исчерпать память сервера. Это вектор атаки на мультиплеерных серверах.

- Максимум **32 активных трекера на игрока** (конфигурируемо на сервере, если будет серверный конфиг, иначе — константа).
- При превышении — отправить сообщение в чат игроку (translatable, `Component.translatable("itemflowmonitor.limit_reached")`).
- Новый трекер не создаётся, существующие продолжают работать.
- Для подсчёта — отслеживать, кто создал трекер (хранить `UUID` создателя в `ContainerTracker` или отдельная `Map<UUID, Set<BlockPos>>`).

**Файлы:** `TrackerManager.java`, `TrackerNetworking.java`, lang-файлы.

**Тест:**
1. Создать 32 трекера → 33-й не создаётся, сообщение в чат.
2. Удалить один → теперь можно создать новый.
3. Два игрока — у каждого свой лимит.

### 12.4 — Разрушение контейнера не игроком (крипер, TNT, визер и т.д.) ✅ DONE

Сейчас удаление трекера при разрушении контейнера реализовано через `PlayerBlockBreakEvents.AFTER` (этап 5.2). Это срабатывает **только** когда блок ломает игрок. Если контейнер уничтожен взрывом (крипер, TNT, визер, заряженный крипер, кристалл Энда, бед в Незере) или другим способом (поршень, вода для некоторых блоков) — трекер остаётся висеть на несуществующем блоке.

**Нужно исследовать:**
1. Какие события Fabric API покрывают разрушение блока не игроком? Проверить `ServerBlockEvents.BLOCK_DESTROYED` (если существует), `ExplosionEvents`, или аналоги.
2. Если нет подходящего события — альтернатива: **периодическая валидация.** Раз в N тиков (например, 200 = 10 сек) проверять для каждого трекера, что блок по `BlockPos` всё ещё является контейнером. Если нет — удалить трекер.
3. Рассмотреть серверный Mixin на `Level.removeBlock()` или `Explosion.finalizeExplosion()` как точку перехвата.
4. Взаимодействие с 11.5 (ghost-трекеры): таймаут покроет этот кейс частично, но лучше чистить сразу.

**Сценарии для тестирования:**
1. Сундук с активным трекером → крипер взрывает → трекер должен удалиться.
2. Двойной сундук с трекером → TNT уничтожает одну половину → трекер удаляется (или перепривязывается к оставшейся?).
3. Воронка с трекером → визер ломает → трекер удаляется.
4. Бочка с трекером → поршень сдвигает (если возможно) → что происходит?
5. Контейнер в выгруженном чанке — трекер не должен крашить при проверке.

**Файлы:** `ItemFlowMonitor.java` (новое событие или периодическая проверка), `TrackerManager.java`.

**Тест:** Для каждого сценария выше — убедиться что трекер корректно удаляется и `TrackerSavedData` обновляется.

### 12.5 — Устойчивость TrackerSavedData к повреждениям ✅ DONE

Мод пишет файл в папку мира (`world/data/`). Если файл повреждён (битый NBT, неполная запись при крэше, ручное редактирование) — мод **не должен** крашить загрузку мира. **Загрузка мира — священная операция, мод не имеет права её сломать.**

**Требования:**
- Десериализация (`Codec.parse`) обёрнута в `try-catch`. При ошибке — логировать WARN с описанием проблемы, создать пустой `TrackerSavedData` с дефолтами. Игрок потеряет настройки трекеров, но мир загрузится.
- Проверить поведение Mojang `Codec` при отсутствующих/лишних полях — `optionalFieldOf` должен покрывать это, но протестировать.
- Проверить что запись данных атомарна (Minecraft `SavedData` обычно пишет во временный файл и переименовывает — убедиться что мы не обходим этот механизм).

**Файлы:** `tracker/TrackerSavedData.java`.

**Тест:**
1. Нормальная работа → сохранить → перезагрузить → настройки на месте (уже работает).
2. Вручную испортить файл `world/data/itemflowmonitor_trackers.dat` (переименовать, записать мусор) → загрузить мир → мир загружается, мод работает, в логе WARN.
3. Удалить файл данных → загрузить мир → мод создаёт новый файл.
4. Добавить неизвестные поля в файл данных → мод их игнорирует.

### 12.6 — Тест: удаление мода (чистый выход) ✅ DONE (тест-план подготовлен)

Самый важный тест с точки зрения пользователя. Игрок поставил мод, поиграл неделю, решил удалить. **Мир должен открыться без единой ошибки.** Если удаление мода ломает мир — это катастрофа для репутации.

**Что проверить:**
- `SavedData` файл остаётся в `world/data/` — Minecraft **должен его проигнорировать** (не пытаться десериализовать без мода). Проверить что ключ регистрации уникален и привязан к моду.
- Миксин исчезает — воронки работают как раньше. `addItem()` возвращается к vanilla-поведению.
- Никаких модифицированных блоков, предметов, entities, chunk data в мире (у нас их нет — это плюс, но убедиться).
- `fabric.mod.json` не регистрирует custom registry entries, custom block entities, custom items.
- Config файл (`config/itemflowmonitor.json`) остаётся — не критично, не мешает.

**Полный цикл тестирования:**
1. Установить мод → создать мир → настроить 5+ трекеров на разных контейнерах → поиграть 10 минут → сохранить и выйти.
2. Удалить jar мода из `mods/`.
3. Запустить игру → загрузить тот же мир.
4. Проверить: мир загружается без ошибок в логе, воронки передают предметы, сундуки открываются, нет крашей.
5. Поиграть 10 минут — стабильность.
6. Проверить `latest.log` — ни одного ERROR или WARN связанного с `itemflowmonitor`.

### 12.7 — Тест: установка мода на существующий мир ✅ DONE (тест-план подготовлен)

Обратный тест. Взять мир с историей: постройки, фермы с воронками, редстоун-механизмы, хранилища. **Мод не должен ничего менять в мире при установке.**

**Полный цикл тестирования:**
1. Запустить мир **без** мода → убедиться что всё работает (baseline).
2. Установить мод → запустить тот же мир.
3. Проверить: мир загрузился без ошибок, всё на месте — блоки, предметы, редстоун.
4. Воронки работают как раньше (мод не замедлил, не сломал передачу).
5. Открыть контейнеры — кнопка IFM появляется. Настроить трекер — работает.
6. Поиграть 10 минут — стабильность.
7. Проверить `latest.log` — только 1 строка инициализации мода, никаких ошибок.

### 12.8 — Профилирование hot path: влияние на тики воронок ✅ DONE

Миксин добавляет код в горячий путь — `addItem()` вызывается каждый раз при передаче предмета воронкой. На сервере с 200 воронками — это 200 вызовов за тик (при максимальной нагрузке). **Мод-наблюдатель не имеет права замедлять то, что наблюдает.**

**Методика:**
1. Измерить overhead одного вызова миксина **без активного трекера** (worst case — 200 воронок, 0 трекеров). Код должен выходить за одну проверку `hasTracker(pos)` → `return`. Цель: **<100 наносекунд** на вызов.
2. Измерить overhead **с активным трекером** (воронка с трекером). Запись события + расчёт позиции. Цель: **<1 микросекунда** на вызов.
3. Суммарное влияние на MSPT (milliseconds per tick): 200 воронок × overhead = ? Цель: **<0.1ms** добавки к тику.

**Инструменты:** Spark profiler (Fabric-совместимый), `/spark tickmonitor`, или ручной `System.nanoTime()` замер в dev-среде.

**Критичный момент:** Если `hasTracker()` делает HashMap lookup по `BlockPos` — это O(1), но `BlockPos.hashCode()` вызывается каждый раз. Для `CompoundContainer` нужна нормализация через `ChestUtil` — это дополнительный overhead. Убедиться что в миксине **нет** нормализации для одинарных контейнеров (оптимизация: сначала проверить простой `BlockPos`, нормализовать только если это `CompoundContainer`).

**Файлы:** `mixin/HopperBlockEntityMixin.java`, `tracker/TrackerManager.java`.

**Тест:** Spark профиль до и после установки мода с 200 воронками. Разница в MSPT < 0.1ms.

### 12.9 — Исследование производительности (бенчмарк FPS/TPS) ✅ DONE (тест-план подготовлен)

Провести полноценное исследование влияния мода на производительность. Не просто "проверить что не лагает", а замерить конкретные метрики:

**Методика:**
1. **Baseline без мода:** Замерить FPS (F3) и TPS (Spark или `/tick`) в тестовом мире с фермой (20+ хопперов в цепочке).
2. **С модом, без трекеров:** Мод установлен, но ни один трекер не активен. Сравнить FPS/TPS.
3. **С модом, 1 трекер:** Один активный трекер на загруженной воронке. Замерить.
4. **С модом, 10 трекеров:** 10 активных трекеров. Замерить.
5. **С модом, 32 трекера (лимит):** Максимальная нагрузка. Замерить.
6. **С открытым GUI + overlay:** FPS при открытом контейнере с активным overlay.

**Что замерять:**
- FPS (средний, 1% low)
- TPS (mspt через Spark)
- Потребление памяти (F3)
- Количество сетевых пакетов (после 11.1 оптимизации)

**Критерии приемлемости:**
- Без трекеров: 0% влияния на FPS/TPS (mixin не должен тормозить если нет трекера на контейнере).
- 10 трекеров: <1% потеря TPS.
- 32 трекера: <3% потеря TPS.
- Overlay: <5 FPS потеря.

**Файлы:** Результаты записать в `PERFORMANCE.md` (или секцию в этом плане).

**Тест:** Провести бенчмарк по методике выше. Если результаты не укладываются в критерии — профилировать и оптимизировать.

### 12.10 — Потокобезопасность: concurrent modification ✅ DONE (анализ: всё в server thread)

В мультиплеере два игрока могут одновременно взаимодействовать с трекером на одном контейнере: один открывает GUI и меняет настройки, другой открывает тот же контейнер. Также серверный тик может итерировать коллекции трекера в момент модификации. **Race condition в серверном коде — потенциальный краш или дюп предметов.**

**Что проверить:**
1. **`ContainerTracker.events` (LinkedList):** `recordEvent()` добавляет элементы, `getRate()` итерирует. Если оба вызваны из разных потоков — `ConcurrentModificationException`. Проверить: вызываются ли они из одного потока (server tick thread)? Minecraft server обычно однопоточный для game logic, но networking может быть в другом потоке.
2. **`TrackerManager.trackers` (Map):** `getOrCreate()` и `remove()` модифицируют. `tickTrackers()` итерирует. Проверить потокобезопасность или гарантию однопоточности.
3. **`TrackerManager.viewers` (Map):** Модифицируется при подписке/отписке (из networking handler) и читается при тике. Проверить что networking handler и тик выполняются в одном потоке (server thread).
4. **`ContainerTracker` поля:** `trackedItem`, `mode`, `period` могут быть изменены одним игроком пока другой читает. В Java примитивы и ссылки — атомарны, но составные операции (check-then-act) — нет.

**Решение (если проблема подтвердится):**
- Если всё в одном потоке (server thread) — проблемы нет, задокументировать это.
- Если есть многопоточность — использовать `ConcurrentHashMap`, `CopyOnWriteArrayList`, или `synchronized` блоки в критических секциях.

**Тест:**
1. Два игрока открывают один контейнер одновременно → оба видят трекер, настройки синхронизированы.
2. Один игрок меняет настройки → второй видит обновление.
3. Один игрок закрывает GUI → второй продолжает видеть rate.
4. Стресс-тест (если возможно): быстрое открытие/закрытие GUI + поток предметов → нет исключений в логе.

---

## Этап 13: Подготовка к публикации

### 13.1 — Иконка мода

Создать иконку 128×128 пикселей в стиле Minecraft. Концепт: стилизованная воронка или сундук с цифрами/графиком потока. PNG с прозрачным фоном.

**Файл:** `src/main/resources/assets/itemflowmonitor/icon.png`

**Тест:** Иконка видна в Mod Menu, в списке модов Fabric Loader. Не мыльная, стиль Minecraft.

### 13.2 — Метаданные мода

Обновить `fabric.mod.json`:
- Описание — развёрнутое, с ключевыми features
- `contact` — GitHub repo, issues URL
- `homepage` — CurseForge/Modrinth ссылка
- `sources` — GitHub
- `suggests` — modmenu

Обновить `gradle.properties`:
- Версия → 1.0.0

**Файлы:** `fabric.mod.json`, `gradle.properties`.

**Тест:** Mod Menu показывает полную информацию: описание, автор, ссылки, лицензия.

### 13.3 — README и документация

Создать `README.md` для GitHub:
- Описание мода с GIF/скриншотами
- Список features
- Инструкция по установке
- Скриншоты UI
- Ссылки на скачивание (CurseForge, Modrinth)
- Contributing guide
- License

**Файл:** `README.md`

**Тест:** README читается на GitHub, изображения загружаются, ссылки работают.

### 13.4 — Changelog

Создать `CHANGELOG.md` в формате Keep a Changelog:
- v1.0.0 — полный список features

**Файл:** `CHANGELOG.md`

### 13.5 — Тестирование на версиях Minecraft

Цель: определить совместимость и при необходимости адаптировать.

| Версия | Приоритет | Ожидание |
|--------|-----------|----------|
| 1.21.11 | ✅ Основная | Полная поддержка |
| 1.21.4 | Высокий | Минимальные изменения API |
| 1.21.1 | Средний | Возможны изменения в networking |
| 1.20.6 | Низкий | Значительные изменения API |
| 1.20.1 | Низкий | Другая система networking |

**Подход:** Ветки в git для каждой поддерживаемой версии. Или multi-version через Preprocessor (Replay Mod style). Решение — после тестирования 1.21.4.

**Тест:** Для каждой версии: запустить инстанс → мод загрузился → открыть сундук → IFM работает → трекинг считает → настройки сохраняются.

### 13.6 — Публикация

1. Создать GitHub репозиторий (если ещё нет)
2. Загрузить на [Modrinth](https://modrinth.com/) — основная платформа
3. Загрузить на [CurseForge](https://www.curseforge.com/) — дополнительно
4. Описание страницы: features, скриншоты, поддерживаемые версии
5. Теги: utility, QoL, storage, automation, redstone
6. Настроить CI/CD (GitHub Actions) для автосборки релизов

**Тест:** Страница мода доступна. Скачивание работает. Установка по инструкции — мод загружается и работает.

### 13.7 — Тестирование совместимости с популярными модами

Проверить что мод не конфликтует с популярными модами, особенно теми, которые модифицируют GUI контейнеров или рендеринг.

**Минимальный набор для тестирования:**

| Мод | Почему важен | На что смотреть |
|-----|-------------|-----------------|
| **Sodium** | Рендер-мод #1, меняет pipeline | FPS, корректность overlay |
| **Lithium** | Оптимизация серверной логики, в т.ч. хопперов | TPS, корректность mixin (HopperBlockEntityMixin может конфликтовать) |
| **Iris** | Шейдеры поверх Sodium | Overlay видимость, z-order |
| **Mod Menu** | Уже интегрирован, но проверить | Config screen, иконка |
| **Inventory Profiles Next** | Добавляет кнопки в GUI контейнеров | Позиционный конфликт с кнопкой IFM, наложение UI элементов |
| **REI / EMI** | Recipe viewers, добавляют панели в GUI | Перекрытие панели IFM, клик-зоны |

**Тест для каждого мода:**
1. Установить мод + IFM → игра запускается без крашей.
2. Открыть сундук → кнопка IFM на месте, не перекрыта другими элементами.
3. Открыть панель IFM → панель не конфликтует с UI другого мода.
4. Активный трекер → overlay отображается корректно.
5. Для Lithium: ✅ Решено Observer-подходом (13.8).

**Lithium — решено:** Observer-подход заменил mixin. Совместимость подтверждена.

### 13.8 — Observer-подход для Lithium-совместимости ✅ DONE

Lithium обходил `addItem()`, mixin не срабатывал. Решение: **сравнение содержимого контейнера каждый тик** через `ContainerObserver`.

**Преимущества:** работает с Lithium и любыми модами; ловит все источники предметов; не зависит от внутренней реализации Minecraft.

**Реализация:**
- `tracker/ContainerObserver.java` — `Map<BlockPos, SlotSnapshot[]>`, сравнение слотов каждый тик, запись положительных дельт
- Интегрирован в `TrackerNetworking.tick()` до обработки viewer'ов
- `mixin/HopperBlockEntityMixin.java` удалён, `itemflowmonitor.mixins.json` — пустой массив

**Тест:** ✅ Работает с Lithium и без. Хопперы, ручная вставка — всё трекается.

---

## Этап 14: Дополнительные фичи (Quality of Life)

### 14.1 — Копирование rate в чат по Shift+клик

По `Shift+клик` на overlay rate — скопировать текущее значение в чат как client-side сообщение (видно только игроку, не отправляется на сервер).

**Формат:**
- Режим конкретного предмета: `[IFM] Iron Ingot: 127/min`
- Режим All: `[IFM] All Items: 127/min`
- С учётом форматирования больших чисел (если 11.2 реализовано): `[IFM] Iron Ingot: 1.2K/hr`

**Реализация:**
- Определить клик-зону overlay (иконка + текст rate).
- При `Shift+клик` — `Minecraft.getInstance().gui.getChat().addMessage(Component.literal(...))` или `player.displayClientMessage(...)`.
- Визуальный фидбек: кратковременное мигание overlay (или звук UI click).

**Файлы:** `ItemFlowMonitorClient.java` — обработка клика в `renderRateOverlay()` или отдельный `mouseClicked` handler. Lang-файлы — формат сообщения (если нужен translatable prefix).

**Тест:**
1. Активный трекер с rate > 0 → Shift+клик на overlay → в чате сообщение `[IFM] Iron Ingot: 150/min`.
2. Режим All → `[IFM] All Items: 150/min`.
3. Без Shift → обычный клик, ничего не происходит.
4. Rate == 0 → `[IFM] Iron Ingot: 0/min`.

---

## Архитектура (итог)

### Файловая структура (целевая)
```
src/main/java/com/itemflowmonitor/
├── ItemFlowMonitor.java            — точка входа, команды, события
├── RateMode.java                   — enum: AVERAGE, ACTUAL, PREDICTED
├── TrackingMode.java               — enum: ALL, AUTO, MANUAL
├── TrackingPeriod.java             — enum: SECOND, MINUTE, HOUR
├── mixin/                          — (пусто, mixin удалён)
├── network/
│   ├── TrackerConfigC2SPacket.java — C2S пакет настроек
│   ├── TrackerUpdateS2CPacket.java — S2C пакет обновления
│   └── TrackerNetworking.java      — регистрация, обработка, тик
├── tracker/
│   ├── ContainerObserver.java      — observer: сравнение слотов каждый тик
│   ├── ContainerTracker.java       — логика трекера (events, rate, EMA)
│   ├── TrackerManager.java         — синглтон-реестр трекеров
│   └── TrackerSavedData.java       — сериализация (Codec)
└── util/
    └── ChestUtil.java              — нормализация двойных сундуков

src/client/java/com/itemflowmonitor/
├── ItemFlowMonitorClient.java      — клиентский entrypoint, UI, keybinding
├── client/
│   ├── SettingsPanel.java          — виджет панели настроек + тултипы
│   └── TrackerClientState.java     — клиентский кеш данных
└── config/
    ├── IFMConfig.java              — модель конфига + JSON I/O
    ├── IFMConfigScreen.java        — экран настроек (custom Screen)
    └── ModMenuIntegration.java     — Mod Menu API интеграция

src/main/resources/assets/itemflowmonitor/
├── icon.png                        — иконка мода 128×128
└── lang/
    ├── en_us.json                  — English (базовый)
    ├── ru_ru.json                  — Русский
    ├── zh_cn.json                  — 简体中文
    ├── zh_tw.json                  — 繁體中文
    ├── de_de.json                  — Deutsch
    ├── fr_fr.json                  — Français
    ├── es_es.json                  — Español
    ├── pt_br.json                  — Português (Brasil)
    ├── ja_jp.json                  — 日本語
    ├── ko_kr.json                  — 한국어
    ├── uk_ua.json                  — Українська
    └── pl_pl.json                  — Polski
```

### Общие требования к коду

- **Язык:** Java 21
- **Модлоадер:** Fabric (Fabric API)
- **Без новых блоков** — только Mixin и GUI
- **Серверная + клиентская часть** — трекинг на сервере, отображение на клиенте, связь через custom networking
- **Минимальное влияние на производительность** — кольцевой буфер с ограниченным размером, события записываются только если трекер активен для данного контейнера
- **Логирование** — ключевые события (создание/удаление трекера, запись события) логируются на уровне DEBUG
