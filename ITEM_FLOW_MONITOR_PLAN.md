# Item Flow Monitor — План реализации мода

## Описание проекта

Мод для Minecraft (Fabric) добавляет возможность отслеживать поток предметов в контейнерах. При открытии контейнера в GUI появляется кнопка, через которую можно выбрать предмет для отслеживания, период и режим расчёта. Компактный счётчик в углу интерфейса показывает, сколько выбранных предметов поступило за выбранный период. Никаких новых блоков — только UI поверх стандартных контейнеров.

**Стек:** Fabric + Fabric API, Minecraft 1.21.11, Java 21, Mixin, Mojang Mappings.

---

## Этап 0: Инициализация проекта ✅ DONE

### 0.1 — Генерация проекта из Fabric template ✅ DONE

Создать проект из шаблона Fabric mod. Настроить `fabric.mod.json`, `build.gradle`, группу и ID мода (`itemflowmonitor`).

**Результат:** Проект создан из `fabric-example-mod`. Версии: MC 1.21.11, Fabric Loader 0.18.4, Fabric API 0.141.2, Loom 1.14. `./gradlew build` — SUCCESS. Jar скопирован в инстанс `ModDevelop`.

**Тест:** ✅ Инстанс запущен. В логах: `Loading 49 mods: ... itemflowmonitor 0.1.0`. Сообщение `Item Flow Monitor загружен!` в консоли. Мир создан и загружен без ошибок.

### 0.2 — Структура пакетов ✅ DONE

Создать пакеты:
- `com.itemflowmonitor` — точка входа
- `com.itemflowmonitor.client` — клиентская часть (GUI, рендер)
- `com.itemflowmonitor.mixin` — серверные миксины
- `com.itemflowmonitor.mixin.client` — клиентские миксины

(Пакеты `tracker`, `network`, `util` добавлены по ходу реализации)

**Результат:** `./gradlew build` — SUCCESS.

---

## Этап 1: Кнопка в интерфейсе сундука ✅ DONE

### 1.1 + 1.2 — Кнопка IFM в экране сундука ✅ DONE (объединены)

Использован Fabric Screen API (`ScreenEvents.AFTER_INIT`) вместо Mixin — более надёжный подход. При открытии `ContainerScreen` добавляется кнопка "IFM" справа от GUI. Access Widener для доступа к `leftPos`, `topPos`, `imageWidth`. По нажатию — сообщение в чат.

**Результат:** `./gradlew build` — SUCCESS. Jar скопирован.

**Тест:** ✅ Кнопка видна справа от GUI сундука. Нажатие — сообщение в чат. Работает при повторном открытии.

### 1.3 — Кнопка отображается только на контейнерах ✅ DONE

Кнопка привязана к `ContainerScreen`, поэтому появляется только на контейнерах. Бочка тоже использует `ContainerScreen` — это ожидаемо и полезно для будущей поддержки (этап 6).

**Тест:** ✅ Сундук ✅, двойной сундук ✅, бочка ✅ (бонус), инвентарь ❌, верстак ❌.

---

## Этап 2: Панель настроек отслеживания ✅ DONE

### 2.1 — Открытие панели по кнопке ✅ DONE

Кастомный виджет `SettingsPanel` (extends `AbstractWidget`) рисуется поверх GUI контейнера. Toggle по кнопке IFM — показ/скрытие через `Screens.getButtons()`.

**Тест:** ✅ Панель появляется/скрывается по нажатию IFM.

### 2.2 — Выбор периода ✅ DONE

3 кнопки: `/sec`, `/min`, `/hour`. Выбранный подсвечен зелёным. По умолчанию `/min`. (Период `/tick` удалён как бесполезный.)

**Тест:** ✅ Переключение работает, подсветка корректна.

### 2.3 — Режим выбора предмета: "Все", "Авто", "Вручную" ✅ DONE

3 кнопки: `All`, `Auto`, `Manual`. Выбранный подсвечен зелёным. По умолчанию `All`. "Manual" пока без функционала выбора предмета (будет в 2.4).

**Тест:** ✅ Переключение работает, панель отображается корректно (ширина 140px).

### 2.4 — Ручной выбор предмета из содержимого сундука ✅ DONE

В режиме "Вручную" — показать список предметов, которые сейчас лежат в сундуке (иконка + название). Клик по предмету выбирает его для отслеживания. Выбранный предмет отображается на панели.

**Результат:** Панель получает меню контейнера через `screen.getMenu()`. В режиме MANUAL — сканируются уникальные предметы (без инвентаря игрока через `slot.container instanceof Inventory`). Список: иконка 16x16 + название. Клик — выбор (зелёная подсветка), повторный клик — снятие. Панель динамически растёт. До 6 предметов видимых, остальные — "+N more...".

**Тест:** ✅ Подтверждено пользователем.

### 2.5 — Тумблер включения/выключения трекинга ✅ DONE

Toggle ON/OFF на панели. По умолчанию OFF. Когда OFF — секции настроек скрыты (компактная панель). Когда ON — полная панель. Выключение отправляет `active=false` на сервер, удаляя трекер.

**Тест:** ✅ Подтверждено пользователем.

### 2.6 — Режим расчёта rate ✅ DONE

3 кнопки: `Actual`, `Predict`, `Average`.
- **Actual** — фактическое количество за скользящее окно периода.
- **Predict** — экстраполяция из 10-секундного окна + EMA-сглаживание (alpha=0.05). Быстрая реакция.
- **Average** — среднее с момента старта/Reset: `totalItems / elapsedTicks * periodTicks`. Стабильная средняя производительность для ферм.

**Результат:** `RateMode` enum. В `ContainerTracker`: PREDICTED с EMA + округлением, AVERAGE с `startTick`. Пакеты и сериализация обновлены (backward-compatible через `optionalFieldOf`).

**Тест:** ✅ Подтверждено пользователем. Воронка стабильно показывает 150/min в Predict.

### 2.7 — Кнопка Reset ✅ DONE

Кнопка "Reset" на строке заголовка панели (красная при наведении). Сбрасывает буфер событий, EMA-сглаживание и startTick. Сигнал: `modeOrdinal=-2`.

**Тест:** ✅ Подтверждено пользователем.

---

## Этап 3: Серверная логика — отслеживание поступления предметов ✅ DONE

### 3.1 — Структура данных TrackerData ✅ DONE

**Результат:** `tracker/ContainerTracker.java` — привязка к BlockPos, режим, предмет, период, rateMode, кольцевой буфер `LinkedList<ItemEvent>` с авто-очисткой (>72000 тиков). Методы: `recordEvent()`, `getRate()`, `clearEvents()`. EMA-сглаживание для PREDICTED, cumulative average для AVERAGE.

### 3.2 — Глобальный реестр трекеров TrackerManager ✅ DONE

**Результат:** `tracker/TrackerManager.java` — синглтон с `Map<BlockPos, ContainerTracker>`. Методы: `getOrCreate()`, `getTracker()`, `remove()`, `hasTracker()`, `clear()`.

### 3.3 — Детекция поступления предметов в контейнер ✅ DONE (пересмотрен: Observer вместо Mixin)

**Было:** `mixin/HopperBlockEntityMixin.java` — хук в `addItem()`. **Удалён в 13.13** из-за несовместимости с Lithium.

**Стало:** `tracker/ContainerObserver.java` — observer-подход: сравнение содержимого контейнеров каждый тик, запись положительных дельт. Работает с любыми модами.

**Тест:** ✅ Одинарный сундук: 150 items/min (корректно для хоппера). Двойной сундук: работает с каноническими позициями.

### 3.4 — Режим "Авто": привязка к первому предмету ✅ DONE

**Результат:** Встроено в `ContainerTracker.recordEvent()` — при `mode == AUTO && trackedItem == null` фиксирует `item` из первого события.

---

## Этап 4: Подсчёт и отображение rates ✅ DONE

### 4.1–4.4 — Networking + Rate overlay ✅ DONE

**Результат:** Полная сетевая интеграция:
- `network/TrackerConfigC2SPacket.java` — C2S пакет (pos, active, modeOrdinal, periodOrdinal, rateModeOrdinal, itemId). Сигналы: -1=subscribe, -2=reset.
- `network/TrackerUpdateS2CPacket.java` — S2C пакет (pos, active, rate, modeOrdinal, periodOrdinal, rateModeOrdinal, trackedItemId)
- `network/TrackerNetworking.java` — серверная обработка + тик (каждый тик для мгновенного обновления)
- `client/TrackerClientState.java` — клиентский кеш по BlockPos с `removeFromCache()`
- `ItemFlowMonitorClient.java` — обработка S2C, кнопка IFM, rate overlay, deferred focus removal
- `SettingsPanel.java` — callback `onSettingsChanged` и `onReset` для отправки C2S
- `TrackerManager.java` — отслеживание viewer'ов (UUID → BlockPos)

Rate overlay: иконка предмета + значение + период в правом верхнем углу GUI. Epsilon-проверка для целочисленного отображения (0 вместо 0.0).

**Тест:** ✅ Подтверждено пользователем.

---

## Этап 5: Полировка и edge cases ✅ DONE

### 5.1 — Сохранение настроек трекера при перезаходе ✅ DONE

**Результат:** `tracker/TrackerSavedData.java` — сериализация через Mojang `Codec` с `RecordCodecBuilder`. `TrackerEntry` (pos, mode, period, rateMode, itemId). `optionalFieldOf("rateMode", 0)` для backward compatibility. Загрузка при `SERVER_STARTED`, автосохранение через `markDirtyIfLoaded()`.

**Тест:** ✅ Настройки трекеров сохраняются между перезаходами. Rate начинает считать заново (буфер не сохраняется).

### 5.2 — Удаление трекера при разрушении контейнера ✅ DONE

**Результат:** `PlayerBlockBreakEvents.AFTER` в `ItemFlowMonitor.onInitialize()`. Использует old `BlockState` для определения типа сундука. Для двойных сундуков — проверяет обе половины и удаляет трекер. `TrackerSavedData.markDirtyIfLoaded()` для сохранения.

**Тест:** ✅ Подтверждено пользователем. Сломать сундук с трекером → трекер удаляется. Новый сундук на том же месте — чист.

### 5.3 — Двойной сундук ✅ DONE

**Результат:** `util/ChestUtil.java` — нормализация позиции двойного сундука к «каноническому» блоку (меньшие координаты). Два метода: `getCanonicalPos(Level, BlockPos)` для клиента, `getCanonicalPosFromCompound(CompoundContainer)` для мixin. Клиент нормализует при `captureContainerPos()`, мixin нормализует при записи событий.

**Тест:** ✅ Подтверждено пользователем. Двойной сундук — одна панель, один трекер, один счётчик.

### 5.4 — Кнопка сброса счётчика ✅ DONE

**Результат:** Кнопка "Reset" на панели, сигнал `modeOrdinal=-2` на сервер. Сервер вызывает `tracker.clearEvents()` + отправляет обновление. Сбрасывает буфер, EMA и startTick.

**Тест:** ✅ Подтверждено пользователем.

### 5.5 — Визуальная индикация активного трекера — SKIPPED

Решено пропустить. Не критично для функциональности.

---

## Этап 6: Поддержка всех контейнеров ✅ DONE

### 6.1 — Абстракция ITrackableContainer — SKIPPED (не нужна)

Текущая архитектура уже поддерживает все контейнеры без абстракции:
- Экран: Fabric Screen API с whitelist `isStorageScreen()` — работает на любом `AbstractContainerScreen`
- Трекинг: `ContainerObserver` сравнивает содержимое **любого** контейнера каждый тик (ранее — Mixin на `addItem()`, заменён в 13.13)

### 6.2 + 6.3 — Все контейнеры-хранилища ✅ DONE (объединены)

**Результат:** Рефакторинг `ItemFlowMonitorClient` — все методы работают с `AbstractContainerScreen<?>`. Whitelist поддерживаемых экранов:
- `ContainerScreen` — сундук (одинарный/двойной), бочка, эндер-сундук
- `ShulkerBoxScreen` — шулкер-бокс
- `HopperScreen` — воронка (считает только входящие, исходящие идут в dest другого контейнера)
- `DispenserScreen` — раздатчик, выбрасыватель

**Тест:** ✅ Подтверждено пользователем. Кнопка IFM и трекинг работают на всех контейнерах.

---

## Этап 7: Печки и коптильни ✅ DONE

### 7.1 — Добавить AbstractFurnaceScreen в whitelist ✅ DONE

**Результат:** В `isStorageScreen()` добавлены проверки: `SmokerScreen` → `BlastFurnaceScreen` → `AbstractFurnaceScreen` (fallback для обычной печки). Каждый тип привязан к своему ключу конфига. Порядок `instanceof` важен — конкретные наследники до базового класса.

**Файлы:** `ItemFlowMonitorClient.java` — строки 110–119.

**Тест:** ✅ Подтверждено пользователем. Печка, коптильня, доменная печь — кнопка IFM видна, трекинг работает.

---

## Этап 8: Настройки через Mod Menu ✅ DONE

### 8.1 — Конфиг-файл (JSON) ✅ DONE

**Результат:** `IFMConfig.java` — singleton с lazy-load, сериализация через Gson. 9 типов контейнеров. Дефолт: все `true` кроме `ender_chest: false`. Мерж дефолтов + файла при загрузке (новые ключи подхватываются автоматически).

**Файлы:** `src/client/java/com/itemflowmonitor/config/IFMConfig.java`

**Тест:** ✅ Файл `config/itemflowmonitor.json` создаётся с дефолтами. Эндер-сундук без кнопки. Ручное изменение + перезапуск — работает.

### 8.2 — Экран настроек (Config Screen) ✅ DONE

**Результат:** `IFMConfigScreen` — кастомный `Screen` с 9 toggle-кнопками ON/OFF + кнопка Done. Лейблы слева, кнопки справа. Done сохраняет, Esc отменяет.

**Баг-фиксы при ревью:**
- Цвета `drawString`/`drawCenteredString` были в RGB (`0xFFFFFF`) вместо ARGB (`0xFFFFFFFF`) — текст мог быть невидимым в MC 1.21.6+. Исправлено.
- Лейбл "Dispenser / Dropper" налезал на кнопку ON/OFF. Увеличено расстояние: лейблы `centerX-80`, кнопки `centerX+55`.

**Файлы:** `src/client/java/com/itemflowmonitor/config/IFMConfigScreen.java`

**Тест:** ✅ Все чекбоксы видны, текст читаемый, toggle работает, настройки сохраняются через Done.

### 8.3 — Интеграция с Mod Menu ✅ DONE

**Результат:** `ModMenuIntegration` implements `ModMenuApi`, фабрика для `IFMConfigScreen`. Зависимость `modImplementation` в build.gradle (доступна при компиляции и в dev-среде, не включается в финальный jar). Entrypoint `"modmenu"` в `fabric.mod.json`, `"modmenu": "*"` в `suggests`.

**Файлы:** `ModMenuIntegration.java`, `build.gradle`, `fabric.mod.json`

**Тест:** ✅ Шестерёнка в Mod Menu → экран настроек открывается.

### 8.4 — Интеграция конфига в isStorageScreen() ✅ DONE

**Результат:** `isStorageScreen()` проверяет `IFMConfig.getInstance().isContainerEnabled()` для каждого типа экрана. `ContainerScreen` (сундук/бочка/эндер-сундук) разделяется через `getContainerScreenConfigKey()` по блоку из hitResult.

**Файлы:** `ItemFlowMonitorClient.java` — `isStorageScreen()`, `getContainerScreenConfigKey()`

**Тест:** ✅ Полный цикл: Mod Menu → выключить бочку → сохранить → бочка без кнопки → вернуть → кнопка есть.

---

## Этап 9: Тултипы (подсказки) ✅ DONE

### 9.1 — Система тултипов в SettingsPanel ✅ DONE

**Результат:** Используется MC API `GuiGraphics.setComponentTooltipForNextFrame()` — тултип рендерится фреймворком с автоматическим позиционированием и z-order. Задержка **500ms** (научно обоснована: NNG рекомендует 300–500ms, Windows default 400ms, macOS ~500ms). Логика: `hoveredElementId` определяется в `renderWidget()`, `renderTooltip()` сравнивает с `lastHoveredElement` и отслеживает `hoverStartTimeMs`.

**Файлы:** `SettingsPanel.java` — поля `lastHoveredElement`, `hoverStartTimeMs`, `TOOLTIP_DELAY_MS`; методы `getTooltipForElement()`, `renderTooltip()`.

**Тест:** ✅ Подтверждено пользователем.

### 9.2 — Тултипы для всех элементов панели ✅ DONE

**Результат:** Многострочные тултипы (через `List<Component>`) для rate modes с примерами. Тултип кнопки IFM через `Button.tooltip()` + `setTooltipDelay(500ms)`.

Тексты тултипов (hardcoded English, будут заменены на `Component.translatable()` в этапе 10):
- **Toggle ON/OFF:** "Enable/Disable item tracking for this container"
- **Period /sec|/min|/hour:** "Count items per second/minute/hour"
- **Average (3 строки):** "Average: total items ÷ total time" + пример + "Stable value, good for long-term monitoring"
- **Actual (3 строки):** "Actual: exact count in current time window" + пример + "Resets to 0 at the start of each period"
- **Predicted (3 строки):** "Predicted: estimates full rate from last 10 sec" + пример + "Updates in real-time, reacts to speed changes"
- **Mode All:** "Track all items entering this container"
- **Mode Auto:** "Automatically track the first item type detected"
- **Mode Manual (2 строки):** "Track only one item type" + "Choose from items currently in this container"
- **Reset:** "Clear all recorded data and start fresh"
- **Item list entries:** Полное название предмета (только если обрезано)
- **Кнопка IFM:** "Item Flow Monitor — track items passing through this container"

**Решение:** Порядок RateMode изменён на AVERAGE → ACTUAL → PREDICTED (Average по умолчанию, на первом месте). Ordinal'ы поменялись — несовместимо с ранее сохранёнными данными (мод в разработке, некритично).

**Файлы:** `SettingsPanel.java`, `ItemFlowMonitorClient.java`, `RateMode.java`

**Тест:** ✅ Подтверждено пользователем.

---

## Этап 10: Локализация (i18n) ✅ DONE

### 10.1 + 10.2 — Вынести все строки в lang-файлы + en_us ✅ DONE (объединены)

**Результат:** Все хардкод-строки заменены на `Component.translatable()`:
- `SettingsPanel.java` — заголовок, кнопки (Reset, ON/OFF), лейблы (Period, Rate, Mode, Select item), тултипы, пустой контейнер, "+N more..."
- `IFMConfigScreen.java` — заголовок, подзаголовок, кнопка Done, ON/OFF, названия контейнеров
- `ItemFlowMonitorClient.java` — кнопка IFM, тултип кнопки, rate overlay (period label)
- Enum'ы (`RateMode`, `TrackingMode`, `TrackingPeriod`) — добавлены `translationKey`, `getTranslationKey()`, `getComponent()`. `getLabel()` сохранён для серверных debug-команд.

**Файл:** `src/main/resources/assets/itemflowmonitor/lang/en_us.json` — 57 ключей.

**Тест:** `./gradlew build` — SUCCESS.

### 10.3 — Русский: ru_ru ✅ DONE

**Файл:** `src/main/resources/assets/itemflowmonitor/lang/ru_ru.json`

**Тест:** `./gradlew build` — SUCCESS.

### 10.4 — Дополнительные языки ✅ DONE

12 языков: en_us, ru_ru, zh_cn, zh_tw, de_de, fr_fr, es_es, pt_br, ja_jp, ko_kr, uk_ua, pl_pl.

**Файлы:** `src/main/resources/assets/itemflowmonitor/lang/*.json`

**Тест:** `./gradlew build` — SUCCESS. Jar скопирован в тестовый инстанс.

---

## Этап 11: Оптимизация и качество кода

### 11.1 — Оптимизация сетевых пакетов ✅ DONE

Сейчас S2C пакет отправляется каждый тик. Оптимизация: отправлять только при изменении rate (delta > 0.01) или раз в 20 тиков (1 сек fallback). Экономия трафика ~95%.

**Результат:** Delta-check + fallback interval в `tick()`. Группировка viewer'ов по BlockPos — один расчёт на контейнер. Кеш `CachedState` per-BlockPos. Вынос построения пакета в `buildUpdatePacket()`. Очистка кеша при удалении трекера и остановке сервера.

**Файлы:** `TrackerNetworking.java`, `ItemFlowMonitor.java`.

**Тест:** ✅ Подтверждено пользователем.

### 11.2 — Форматирование больших чисел ✅ DONE

Для rate >= 10000: компактный формат "15K", "1.5M". До 10K — полное число.

**Результат:** Метод `formatRate()` в `ItemFlowMonitorClient`. Пороги: >=1M → "1.5M"/"15M", >=10K → "15K"/"100K", >=10 → целое, <10 → одна десятая.

**Файлы:** `ItemFlowMonitorClient.java` — `formatRate()`.

**Тест:** ✅ Подтверждено пользователем.

### 11.3 — Цветовая индикация rate ✅ DONE

Цвет числа rate в overlay зависит от потока:
- Белый (`0xFFFFFFFF`) — предметы поступают (rate > 0)
- Тёмно-серый (`0xFF555555`) — нет потока (rate == 0)

Жёлтый цвет ("мало предметов") убран — субъективный порог, бесполезен при наличии числового значения.

**Файлы:** `ItemFlowMonitorClient.java` — `renderRateOverlay()`.

**Тест:** Активный поток → светлый текст. Остановить поток → серый текст.

### 11.4 — Очистка и рефакторинг ✅ DONE

- **Удалены debug-команды `/ifm track|info|remove` полностью.** Метод `registerCommands()` и неиспользуемые импорты удалены из `ItemFlowMonitor.java`.
- **Ревизия TODO/FIXME** — ни одного не найдено в коде.
- **Проверка утечек памяти** — `TrackerClientState.clearCache()` вызывается при `DISCONNECT`. Утечек нет.
- **Валидация itemId** — try-catch для `Identifier.parse()`, ограничение длины 256 символов.

**Файлы:** `ItemFlowMonitor.java`, `TrackerNetworking.java`.

**Тест:** ✅ Build SUCCESS. `/ifm` больше не регистрируется.

### 11.5 — Защита от ghost-трекеров ✅ DONE

**Результат:** Механизм паузы ghost-трекеров:
- `ContainerTracker`: добавлены `lastViewerTick`, `paused`, метод `markViewerActive()` (обновляет таймер + снимает паузу)
- `TrackerNetworking`: ghost-check каждые 200 тиков (10 сек) — если нет viewer'ов > 6000 тиков (5 мин) → пауза + очистка буфера
- `ContainerObserver`: `tracker.isPaused()` проверка — приостановленные трекеры не наблюдаются (ранее — в `HopperBlockEntityMixin`, заменён в 13.13)
- `ServerPlayConnectionEvents.DISCONNECT` handler — немедленная очистка viewer'а
- При подписке/настройках — `markViewerActive()` снимает паузу
- При загрузке из save — `lastViewerTick = currentGameTime` (отсчёт ghost-таймера с момента загрузки)

**Файлы:** `ContainerTracker.java`, `TrackerNetworking.java`, `ContainerObserver.java`, `TrackerSavedData.java`.

**Тест:** ✅ Build SUCCESS.

### 11.6 — Ревизия логирования ✅ DONE

**Результат:** Аудит всех 15 вызовов LOGGER + проверка System.out/err (нет).
- **info → debug:** `TrackerSavedData` (загрузка трекеров), `ItemFlowMonitorClient` (инициализация клиента), `IFMConfig` (загрузка/сохранение конфига)
- **Оставлен 1 info:** `ItemFlowMonitor.java` — "Item Flow Monitor загружен!" (инициализация мода)
- **warn/error:** корректны (ошибка чтения конфига, ошибка сохранения конфига)
- **debug:** все вне hot path (по действиям игрока, при сохранении мира)
- **System.out/err:** отсутствуют
- **Observer:** логирование ошибок через rate-limited WARN (не чаще 1 раза в 60 сек), никаких debug-логов в tick loop

**Файлы:** `ItemFlowMonitorClient.java`, `TrackerSavedData.java`, `IFMConfig.java`.

### 11.7 — Баг: разрушение половины двойного сундука теряет трекер ✅ DONE

**Результат:** При разрушении половины двойного сундука трекер **переносится** на оставшуюся половину вместо удаления.
- `TrackerManager.moveTracker(from, to)` — перемещает трекер между позициями (обновляет Map + pos объекта)
- `ContainerTracker.pos` → non-final + package-private `setPos()`
- Обработчик `PlayerBlockBreakEvents.AFTER` переписан: для двойного сундука — moveTracker, для остальных контейнеров — remove
- Если трекер на не-сломанной половине — ничего не делаем (уже корректно)

**Файлы:** `ItemFlowMonitor.java`, `TrackerManager.java`, `ContainerTracker.java`.

**Тест:** Build SUCCESS. Тест-кейсы:
1. Двойной сундук с трекером → сломать каноническую половину → трекер перенесён на вторую
2. Сломать НЕ-каноническую → трекер остаётся
3. Сломать обе → трекер удаляется
4. Открыть оставшийся одинарный → панель показывает сохранённые настройки

---

## Этап 12: Надёжность, безопасность и тестирование ✅ DONE (пересмотрен после Observer 13.13)

> **⚠️ ВАЖНО ДЛЯ АГЕНТА:** Этот этап — критический. Здесь упор на **безопасность, защитное программирование и проверку граничных случаев**. Принцип: мод **не должен навредить пользователю** ни при каких обстоятельствах. Ни крашами, ни потерей данных мира, ни лагами сервера, ни уязвимостями в мультиплеере.
>
> **Подход к реализации каждого пункта:**
> 1. Сначала **исследовать** текущее поведение — прочитать код, понять что происходит сейчас.
> 2. Думать как **злонамеренный пользователь**: что будет если отправить мусорные пакеты? Если спамить трекерами? Если вызвать race condition?
> 3. Думать как **невезучий пользователь**: что будет если крэш во время сохранения? Если мод удалён? Если файл данных повреждён?
> 4. Каждая проверка/валидация должна **fail gracefully**: логировать проблему, продолжить работу. Никогда не крашить сервер, не ломать мир, не терять предметы.
> 5. После каждого изменения — `./gradlew build` + конкретный тест-кейс. Не считать задачу выполненной без проверки.
>
> **Приоритет:** Безопасность > Производительность > Удобство. Если сомневаешься — выбирай более защитный вариант.

### 12.1 — Безопасность наблюдения за контейнерами ✅ DONE (пересмотрен: Observer вместо Mixin)

> **Было (Mixin):** `HopperBlockEntityMixin` хукал `addItem()` — вмешательство в vanilla hot path. Риски: крэш тика, модификация ItemStack, утечка ThreadLocal.
>
> **Стало (Observer):** `ContainerObserver` сравнивает содержимое контейнеров каждый тик из `TrackerNetworking.tick()`. **Не вмешивается в vanilla-логику вообще** — только читает `container.getItem(i)`. Mixin удалён.

**Защитные меры в Observer (аналоги 12.1 для mixin):**
- **try-catch per-трекер** — каждый контейнер обрабатывается в изолированном `try-catch(Exception e)`. Исключение в одном контейнере (баговый мод-блок, повреждённый BlockEntity) логируется WARN с rate-limit (60 сек) и не влияет на остальные трекеры и серверный тик.
- **Только чтение** — observer не модифицирует содержимое контейнеров. Вызывает только `container.getItem(i)` и `container.getContainerSize()`. Нет риска потери предметов.
- **`MAX_CONTAINER_SIZE = 256`** — защита от OOM если мод-блок вернёт аномальный `getContainerSize()`. Vanilla максимум — 54 (двойной сундук).
- **Нет ThreadLocal** — observer не использует ThreadLocal (в отличие от mixin), нет риска утечки.
- **Paused трекеры пропускаются** — `if (tracker.isPaused()) continue` в начале цикла.

**Файлы:** `tracker/ContainerObserver.java`.

**Результат:** Observer безопаснее mixin — не вмешивается в vanilla-логику, изолирует ошибки per-трекер, не имеет ThreadLocal.

### 12.2 — Валидация BlockPos в C2S пакетах ✅ DONE

Сейчас клиент отправляет любой `BlockPos` в `TrackerConfigC2SPacket`. Злонамеренный клиент может спамить трекерами на произвольные координаты (OOM, лаг сервера). **Никогда не доверять данным от клиента.**

Проверки (все — на серверной стороне):

- Блок должен быть в **загруженном чанке** (`level.isLoaded(pos)`).
- Блок должен быть в **радиусе взаимодействия игрока** (~6 блоков, `player.canInteractWithBlock(pos, 1.0)` или ручной расчёт `distanceSqr`).
- Блок по указанным координатам должен быть **контейнером** (instanceof `BaseContainerBlockEntity` или аналог).
- Валидация `modeOrdinal`, `periodOrdinal`, `rateModeOrdinal` — должны быть в допустимых диапазонах enum'ов. Невалидное значение → игнорировать пакет.
- Валидация `itemId` — не null, не пустая строка длиннее 256 символов, соответствует формату `namespace:path`.
- При невалидном пакете — игнорировать (не крашить, не кикать). Логировать на уровне WARN (с rate-limit).

**Файлы:** `TrackerNetworking.java` — обработчик C2S пакета.

**Тест:**
1. Нормальное использование — трекер создаётся как обычно.
2. (Если возможно симулировать) Отправить BlockPos на 1000 блоков от игрока → сервер игнорирует.
3. Отправить BlockPos в выгруженном чанке → сервер игнорирует.
4. Отправить BlockPos на блок земли → сервер игнорирует.

### 12.3 — Лимит трекеров на игрока ✅ DONE

Без лимита один игрок может создать тысячи трекеров и исчерпать память сервера. Это вектор атаки на мультиплеерных серверах.

- Максимум **32 активных трекера на игрока** (конфигурируемо на сервере, если будет серверный конфиг, иначе — константа).
- При превышении — отправить сообщение в чат игроку (translatable, `Component.translatable("itemflowmonitor.limit_reached")`).
- Новый трекер не создаётся, существующие продолжают работать.
- Для подсчёта — отслеживать, кто создал трекер (хранить `UUID` создателя в `ContainerTracker` или отдельная `Map<UUID, Set<BlockPos>>`).

**Файлы:** `TrackerManager.java`, `TrackerNetworking.java`, lang-файлы.

**Тест:**
1. Создать 32 трекера → 33-й не создаётся, сообщение в чат.
2. Удалить один → теперь можно создать новый.
3. Два игрока — у каждого свой лимит.

### 12.4 — Разрушение контейнера не игроком (крипер, TNT, визер и т.д.) ✅ DONE

Сейчас удаление трекера при разрушении контейнера реализовано через `PlayerBlockBreakEvents.AFTER` (этап 5.2). Это срабатывает **только** когда блок ломает игрок. Если контейнер уничтожен взрывом (крипер, TNT, визер, заряженный крипер, кристалл Энда, бед в Незере) или другим способом (поршень, вода для некоторых блоков) — трекер остаётся висеть на несуществующем блоке.

**Нужно исследовать:**
1. Какие события Fabric API покрывают разрушение блока не игроком? Проверить `ServerBlockEvents.BLOCK_DESTROYED` (если существует), `ExplosionEvents`, или аналоги.
2. Если нет подходящего события — альтернатива: **периодическая валидация.** Раз в N тиков (например, 200 = 10 сек) проверять для каждого трекера, что блок по `BlockPos` всё ещё является контейнером. Если нет — удалить трекер.
3. Рассмотреть серверный Mixin на `Level.removeBlock()` или `Explosion.finalizeExplosion()` как точку перехвата.
4. Взаимодействие с 11.5 (ghost-трекеры): таймаут покроет этот кейс частично, но лучше чистить сразу.

**Сценарии для тестирования:**
1. Сундук с активным трекером → крипер взрывает → трекер должен удалиться.
2. Двойной сундук с трекером → TNT уничтожает одну половину → трекер удаляется (или перепривязывается к оставшейся?).
3. Воронка с трекером → визер ломает → трекер удаляется.
4. Бочка с трекером → поршень сдвигает (если возможно) → что происходит?
5. Контейнер в выгруженном чанке — трекер не должен крашить при проверке.

**Файлы:** `ItemFlowMonitor.java` (новое событие или периодическая проверка), `TrackerManager.java`.

**Тест:** Для каждого сценария выше — убедиться что трекер корректно удаляется и `TrackerSavedData` обновляется.

### 12.5 — Устойчивость TrackerSavedData к повреждениям ✅ DONE

Мод пишет файл в папку мира (`world/data/`). Если файл повреждён (битый NBT, неполная запись при крэше, ручное редактирование) — мод **не должен** крашить загрузку мира. **Загрузка мира — священная операция, мод не имеет права её сломать.**

**Требования:**
- Десериализация (`Codec.parse`) обёрнута в `try-catch`. При ошибке — логировать WARN с описанием проблемы, создать пустой `TrackerSavedData` с дефолтами. Игрок потеряет настройки трекеров, но мир загрузится.
- Проверить поведение Mojang `Codec` при отсутствующих/лишних полях — `optionalFieldOf` должен покрывать это, но протестировать.
- Проверить что запись данных атомарна (Minecraft `SavedData` обычно пишет во временный файл и переименовывает — убедиться что мы не обходим этот механизм).

**Файлы:** `tracker/TrackerSavedData.java`.

**Тест:**
1. Нормальная работа → сохранить → перезагрузить → настройки на месте (уже работает).
2. Вручную испортить файл `world/data/itemflowmonitor_trackers.dat` (переименовать, записать мусор) → загрузить мир → мир загружается, мод работает, в логе WARN.
3. Удалить файл данных → загрузить мир → мод создаёт новый файл.
4. Добавить неизвестные поля в файл данных → мод их игнорирует.

### 12.6 — Тест: удаление мода (чистый выход) ✅ DONE (тест-план подготовлен, пересмотрен после Observer)

Самый важный тест с точки зрения пользователя. Игрок поставил мод, поиграл неделю, решил удалить. **Мир должен открыться без единой ошибки.** Если удаление мода ломает мир — это катастрофа для репутации.

**Что проверить:**
- `SavedData` файл остаётся в `world/data/` — Minecraft **должен его проигнорировать** (не пытаться десериализовать без мода). Проверить что ключ регистрации уникален и привязан к моду.
- ~~Миксин исчезает — воронки работают как раньше.~~ **После Observer:** серверных mixin больше нет (`mixins: []`), мод не вмешивается в vanilla-логику. Удаление мода ещё безопаснее.
- Никаких модифицированных блоков, предметов, entities, chunk data в мире (у нас их нет — это плюс, но убедиться).
- `fabric.mod.json` не регистрирует custom registry entries, custom block entities, custom items.
- Config файл (`config/itemflowmonitor.json`) остаётся — не критично, не мешает.

**Полный цикл тестирования:**
1. Установить мод → создать мир → настроить 5+ трекеров на разных контейнерах → поиграть 10 минут → сохранить и выйти.
2. Удалить jar мода из `mods/`.
3. Запустить игру → загрузить тот же мир.
4. Проверить: мир загружается без ошибок в логе, воронки передают предметы, сундуки открываются, нет крашей.
5. Поиграть 10 минут — стабильность.
6. Проверить `latest.log` — ни одного ERROR или WARN связанного с `itemflowmonitor`.

### 12.7 — Тест: установка мода на существующий мир ✅ DONE (тест-план подготовлен)

Обратный тест. Взять мир с историей: постройки, фермы с воронками, редстоун-механизмы, хранилища. **Мод не должен ничего менять в мире при установке.**

**Полный цикл тестирования:**
1. Запустить мир **без** мода → убедиться что всё работает (baseline).
2. Установить мод → запустить тот же мир.
3. Проверить: мир загрузился без ошибок, всё на месте — блоки, предметы, редстоун.
4. Воронки работают как раньше (мод не замедлил, не сломал передачу).
5. Открыть контейнеры — кнопка IFM появляется. Настроить трекер — работает.
6. Поиграть 10 минут — стабильность.
7. Проверить `latest.log` — только 1 строка инициализации мода, никаких ошибок.

### 12.8 — Профилирование: влияние на серверный тик ✅ DONE (пересмотрен после Observer)

> **Было (Mixin):** код в hot path хопперов — 200 воронок × overhead на каждую передачу. Без трекеров — одна проверка `hasTracker()` и выход.
>
> **Стало (Observer):** overhead пропорционален количеству **активных трекеров**, а не воронок. Без трекеров — пустой цикл по пустой Map. 200 воронок без трекеров = нулевой overhead.

**Характеристики Observer:**
- **Без трекеров:** итерация по пустой `Map` → 0 overhead. Лучше mixin (mixin вызывался на каждой воронке).
- **N трекеров:** N × `getContainerSize()` сравнений + N × `getFullContainer()` вызовов. Для 5 трекеров с двойными сундуками: 5 × 54 × 20 = 5400 сравнений/сек ≈ 0.03ms/тик.
- **100 трекеров (экстрим):** < 0.1ms/тик из бюджета 50ms.
- **Paused трекеры:** пропускаются полностью (`isPaused()` check).

**Файлы:** `tracker/ContainerObserver.java`, `network/TrackerNetworking.java`.

### 12.9 — Исследование производительности (бенчмарк FPS/TPS) ✅ DONE (тест-план подготовлен)

Провести полноценное исследование влияния мода на производительность. Не просто "проверить что не лагает", а замерить конкретные метрики:

**Методика:**
1. **Baseline без мода:** Замерить FPS (F3) и TPS (Spark или `/tick`) в тестовом мире с фермой (20+ хопперов в цепочке).
2. **С модом, без трекеров:** Мод установлен, но ни один трекер не активен. Сравнить FPS/TPS.
3. **С модом, 1 трекер:** Один активный трекер на загруженной воронке. Замерить.
4. **С модом, 10 трекеров:** 10 активных трекеров. Замерить.
5. **С модом, 32 трекера (лимит):** Максимальная нагрузка. Замерить.
6. **С открытым GUI + overlay:** FPS при открытом контейнере с активным overlay.

**Что замерять:**
- FPS (средний, 1% low)
- TPS (mspt через Spark)
- Потребление памяти (F3)
- Количество сетевых пакетов (после 11.1 оптимизации)

**Критерии приемлемости:**
- Без трекеров: 0% влияния на FPS/TPS (observer итерирует пустую Map).
- 10 трекеров: <1% потеря TPS.
- 32 трекера: <3% потеря TPS.
- Overlay: <5 FPS потеря.

**Файлы:** Результаты записать в `PERFORMANCE.md` (или секцию в этом плане).

**Тест:** Провести бенчмарк по методике выше. Если результаты не укладываются в критерии — профилировать и оптимизировать.

### 12.10 — Потокобезопасность: concurrent modification ✅ DONE (анализ: всё в server thread)

В мультиплеере два игрока могут одновременно взаимодействовать с трекером на одном контейнере: один открывает GUI и меняет настройки, другой открывает тот же контейнер. Также серверный тик может итерировать коллекции трекера в момент модификации. **Race condition в серверном коде — потенциальный краш или дюп предметов.**

**Что проверить:**
1. **`ContainerTracker.events` (LinkedList):** `recordEvent()` добавляет элементы, `getRate()` итерирует. Если оба вызваны из разных потоков — `ConcurrentModificationException`. Проверить: вызываются ли они из одного потока (server tick thread)? Minecraft server обычно однопоточный для game logic, но networking может быть в другом потоке.
2. **`TrackerManager.trackers` (Map):** `getOrCreate()` и `remove()` модифицируют. `tickTrackers()` итерирует. Проверить потокобезопасность или гарантию однопоточности.
3. **`TrackerManager.viewers` (Map):** Модифицируется при подписке/отписке (из networking handler) и читается при тике. Проверить что networking handler и тик выполняются в одном потоке (server thread).
4. **`ContainerTracker` поля:** `trackedItem`, `mode`, `period` могут быть изменены одним игроком пока другой читает. В Java примитивы и ссылки — атомарны, но составные операции (check-then-act) — нет.

**Решение (если проблема подтвердится):**
- Если всё в одном потоке (server thread) — проблемы нет, задокументировать это.
- Если есть многопоточность — использовать `ConcurrentHashMap`, `CopyOnWriteArrayList`, или `synchronized` блоки в критических секциях.

**Тест:**
1. Два игрока открывают один контейнер одновременно → оба видят трекер, настройки синхронизированы.
2. Один игрок меняет настройки → второй видит обновление.
3. Один игрок закрывает GUI → второй продолжает видеть rate.
4. Стресс-тест (если возможно): быстрое открытие/закрытие GUI + поток предметов → нет исключений в логе.

---

## Этап 13: Подготовка к публикации

> **Справочный материал:** `MODRINTH_PAGE_BEST_PRACTICES.md` — анализ 20+ модов (700M+ скачиваний). Ключевые эталоны: AppleSkin (фича→скриншот), Zoomify (GIF-демо), Sodium (Before/After), Immersive Overlays (ближайший аналог IFM).

### 13.1 — Иконка мода

Создать иконку **128×128 пикселей** (или больше) в стиле Minecraft. Концепт: стилизованная воронка или сундук с цифрами/графиком потока. PNG с прозрачным фоном.

Иконка используется и в Mod Menu, и на Modrinth/CurseForge — это первое, что видит пользователь в поиске.

**Файл:** `src/main/resources/assets/itemflowmonitor/icon.png`

**Тест:** Иконка видна в Mod Menu, в списке модов Fabric Loader, на Modrinth. Не мыльная, стиль Minecraft, читаема в маленьком размере (32×32 preview).

### 13.2 — Метаданные мода и Modrinth

> **Из лучших практик:** Пустая боковая панель вызывает недоверие. Summary решает — пользователь принимает решение о скачивании за 5-10 секунд.

#### Summary (краткое описание на Modrinth)

**Оптимальная длина: 6-15 слов, одно предложение.** Описывать что видит/получает пользователь, не техническую реализацию.

Варианты:
- `"Real-time item throughput monitoring for any container."` (~7 слов)
- `"Real-time item flow rate overlay for containers — see your farm's items/min."` (~12 слов)

**Правила:**
- Не начинать с "A mod that..." — это очевидно
- Не включать версии Minecraft, названия загрузчиков
- Описывать пользу, не реализацию

#### fabric.mod.json

- `description` — развёрнутое описание (отображается в Mod Menu)
- `contact.homepage` — Modrinth URL
- `contact.sources` — GitHub URL
- `contact.issues` — GitHub Issues URL
- `license` — MIT/LGPL-3.0
- `suggests` — `"modmenu": "*"`

#### gradle.properties

- Версия → `1.0.0`

#### Теги на Modrinth

- **Utility** (обязательно)
- **Storage** (относится к контейнерам)

#### Боковая панель на Modrinth

| Поле | Что писать | Приоритет |
|------|-----------|-----------|
| Report issues | GitHub Issues | Обязательно |
| View source | GitHub Repository | Обязательно |
| Visit wiki | GitHub Wiki (если есть) | Рекомендуется |
| Join Discord | Discord сервер (если есть) | Опционально |
| Donate | Ko-fi / Patreon (если есть) | Опционально |

#### Client/Server совместимость

Указать точно: **"Client and server"** — мод работает на обеих сторонах для полной функциональности. Без сервера — ограниченно.

**Файлы:** `fabric.mod.json`, `gradle.properties`, настройки проекта на Modrinth.

**Тест:** Mod Menu показывает полную информацию. Summary не обрезается в списке Modrinth.

### 13.3 — Визуальный контент (скриншоты, GIF)

> **Из лучших практик:** Для UI-мода скриншоты/GIF обязательны. GIF > статичный скриншот для демонстрации оверлеев. Эталон — паттерн AppleSkin (фича → скриншот) и Zoomify (GIF-демо).

#### Что нужно снять

**GIF (обязательно, минимум 1):**
- Открытие контейнера → появление оверлея с rate в реальном времени (основная демонстрация)

**Скриншоты (минимум 3-4):**
1. Оверлей на сундуке с активным потоком предметов
2. Оверлей на воронке / печке — показать разные контейнеры
3. Панель настроек (SettingsPanel) — все элементы видны
4. Разные режимы: items/min vs items/hour, или Average vs Predicted

**Опционально:**
- Скриншот конфигурации через Mod Menu (IFMConfigScreen)
- Before/After в стиле Sodium (контейнер без мода → с модом)

#### Технические требования

- **Разрешение:** ширина 600-1000px (полная ширина области описания на Modrinth)
- **Формат GIF:** плавный, 15-30 fps, не слишком длинный (5-15 сек)
- **Аннотации на скриншотах:** стрелки, подписи — повышают понятность (паттерн Sodium)
- Все изображения загрузить на CDN Modrinth (через gallery upload) — не внешние хостинги

**Файлы:** Подготовить в отдельной папке `screenshots/` или загрузить напрямую.

**Тест:** Все изображения загружаются на Modrinth, не битые, читаемы на мобильных устройствах.

### 13.4 — Описание страницы на Modrinth

> **Из лучших практик:** Структура — Что → Как → Фичи → Совместимость → FAQ. Списки > прозы. Оптимальная длина: 200-500 слов, не больше 800.

#### Рекомендуемая структура описания

```markdown
<!-- Опционально: центрированный баннер/логотип -->

Real-time item throughput monitoring for Minecraft containers.

**Item Flow Monitor** adds an unobtrusive UI overlay to standard containers
(chests, hoppers, furnaces, and more) that shows the rate of items flowing
through them — in items/sec, items/min, or items/hour. Perfect for players
who build farms and want to measure performance without manual counting.

> This mod does **not** add any new blocks or items. It only adds an
> informational overlay to existing container screens.

![Item Flow Monitor Demo](url_gif)

## Features

- **Real-time flow rate** — see items/sec, items/min or items/hour directly in the container UI
- **Three calculation modes** — Average (stable long-term), Actual (exact count per window), Predicted (real-time estimate with EMA smoothing)
- **All standard containers** — chests, double chests, hoppers, furnaces, blast furnaces, smokers, barrels, dispensers, droppers, shulker boxes
- **Flexible item tracking** — track all items, auto-detect the first item, or manually select a specific item
- **Configurable via Mod Menu** — toggle tracking per container type
- **12 languages** — English, Русский, 中文, Español, Deutsch, Français, 日本語, 한국어, Português, Italiano, Polski, Українська
- **Lightweight** — observer-based architecture, zero overhead without active trackers

## How to Use

1. Install the mod (requires Fabric API)
2. Open any container — click the **IFM** button to open the settings panel
3. Toggle tracking **ON**, choose period and calculation mode
4. The flow rate overlay appears in the corner of the container screen
5. Configure which containers show IFM through **Mod Menu** → Item Flow Monitor

![Settings panel](url_screenshot)

## Compatibility

- **Client + Server:** Install on both sides for accurate real-time data
- **Lithium compatible:** Observer-based tracking, no hopper mixin conflicts
- **Works with:** Mod Menu, Sodium, Iris, Fabric API
- Tested on Minecraft 1.21.11

## FAQ

**Q: Does it work on vanilla servers?**
A: The mod requires server-side installation for tracking. Client-only mode is not currently supported.

**Q: Does it affect performance?**
A: No. The mod only tracks containers with active trackers. Zero overhead without trackers.

**Q: Can I hide the overlay for specific container types?**
A: Yes — configure through Mod Menu → Item Flow Monitor.
```

#### Антипаттерны (чего избегать)

- Стены текста без заголовков (антипример: Mouse Tweaks)
- Описание длиннее 800 слов — вынести детали на wiki
- Реклама в описании
- Битые бейджи/изображения
- Summary длиннее 15 слов
- API-документация для разработчиков на странице для пользователей

**Файл:** Описание создать в `MODRINTH_DESCRIPTION.md` (черновик), затем скопировать на Modrinth.

**Тест:** Описание прочитано «свежими глазами» — понятно ли за 10 секунд что делает мод? Все ссылки и изображения работают.

### 13.5 — Gallery на Modrinth

> **Из лучших практик:** Gallery обязательна. Моды с Gallery выглядят профессиональнее. 4-6 изображений с подписями, не дублировать скриншоты из описания.

**Рекомендуемые изображения (4-6 штук):**

| # | Подпись (caption) | Что показать |
|---|-------------------|-------------|
| 1 | "Item flow overlay on a chest" | Основной оверлей с rate > 0 |
| 2 | "Monitoring a hopper chain" | Воронка с активным потоком |
| 3 | "Furnace throughput tracking" | Печка/коптильня/доменная |
| 4 | "Settings panel with item selection" | Панель настроек в режиме MANUAL с выбранным предметом |
| 5 | "Configuration screen via Mod Menu" | Экран IFMConfigScreen |
| 6 | "Multilingual support (12 languages)" | UI на другом языке (ru_ru / zh_cn) |

**Правила:**
- Каждое изображение с **подписью** (caption) на английском
- Показывать разные аспекты мода — не повторять описание
- Разрешение 600-1000px по ширине

**Тест:** Gallery заполнена, все изображения загружаются, подписи информативны.

### 13.6 — README для GitHub

Создать `README.md` для GitHub-репозитория. README — «лицо» проекта для разработчиков и контрибьюторов. Отличается от описания на Modrinth: более техническое, включает инструкции по сборке.

**Структура:**
- Баннер/иконка + название
- Краткое описание (1-3 предложения)
- Скриншот/GIF — мод в действии
- Features — маркированный список
- Installation — ссылки на Modrinth/CurseForge + ручная инструкция
- Building from source — `./gradlew build`
- Compatibility — MC версии, моды
- Contributing — как помочь (issues, PR, переводы)
- License

**Файл:** `README.md`

**Тест:** README читается на GitHub, изображения загружаются, ссылки работают.

### 13.7 — Changelog

Создать `CHANGELOG.md` в формате [Keep a Changelog](https://keepachangelog.com/):
- v1.0.0 — полный список features, сгруппированных по категориям (Added)

**Файл:** `CHANGELOG.md`

### 13.8 — Лицензия

Выбрать и добавить файл лицензии. Популярные для Fabric-модов: MIT, LGPL-3.0, Apache-2.0.

**Файл:** `LICENSE`

**Тест:** Лицензия указана в `fabric.mod.json`, файл `LICENSE` в корне, Modrinth показывает лицензию.

### 13.9 — Тестирование на версиях Minecraft

Цель: определить совместимость и при необходимости адаптировать.

| Версия | Приоритет | Ожидание |
|--------|-----------|----------|
| 1.21.11 | ✅ Основная | Полная поддержка |
| 1.21.4 | Высокий | Минимальные изменения API |
| 1.21.1 | Средний | Возможны изменения в networking |
| 1.20.6 | Низкий | Значительные изменения API |
| 1.20.1 | Низкий | Другая система networking |

**Подход:** Ветки в git для каждой поддерживаемой версии. Или multi-version через Preprocessor (Replay Mod style). Решение — после тестирования 1.21.4.

**Тест:** Для каждой версии: запустить инстанс → мод загрузился → открыть сундук → IFM работает → трекинг считает → настройки сохраняются.

### 13.10 — Публикация

1. Создать GitHub репозиторий
2. Загрузить на [Modrinth](https://modrinth.com/) — основная платформа
3. Загрузить на [CurseForge](https://www.curseforge.com/) — дополнительно
4. Настроить CI/CD (GitHub Actions) для автосборки релизов

**Тест:** Страница мода доступна. Скачивание работает. Установка по инструкции — мод загружается и работает.

### 13.11 — Финальный чеклист перед публикацией

> **На основе анализа 20+ успешных модов.** Каждый пункт проверен — только потом нажимать «Publish».

#### Метаданные
- [ ] Summary заполнен (6-15 слов, одно предложение, не обрезается в списке)
- [ ] Иконка мода загружена (128×128+, читаема в 32×32 preview)
- [ ] Теги выбраны (Utility, Storage)
- [ ] Платформа указана (Fabric)
- [ ] Client/Server совместимость указана правильно
- [ ] Лицензия указана (в Modrinth + файл LICENSE + fabric.mod.json)
- [ ] Поддерживаемые версии Minecraft указаны
- [ ] Версия мода = 1.0.0

#### Боковая панель (Modrinth)
- [ ] Report issues → GitHub Issues
- [ ] View source → GitHub Repository
- [ ] Visit wiki → GitHub Wiki (если есть)
- [ ] Join Discord → Discord (если есть)

#### Описание
- [ ] Краткое описание в начале (1-3 предложения, что делает мод)
- [ ] Примечание: мод НЕ добавляет новых блоков (для ясности)
- [ ] Минимум 1 GIF + 2-3 скриншота в описании
- [ ] Фичи — маркированный список с **жирными** ключевыми словами
- [ ] Секция "How to Use" с конкретными шагами
- [ ] Информация о совместимости (client/server, Lithium, Sodium)
- [ ] Упомянуты поддерживаемые языки (12 штук)
- [ ] FAQ (минимум 2-3 вопроса)
- [ ] Нет стен текста — все секции с заголовками
- [ ] Длина: 200-500 слов (не больше 800)
- [ ] Описание на английском языке

#### Визуальный контент
- [ ] GIF демонстрирует оверлей в действии
- [ ] Скриншоты показывают оверлей на разных контейнерах
- [ ] Скриншот панели настроек
- [ ] Все изображения загружаются корректно (не битые)
- [ ] Разрешение 600-1000px по ширине

#### Gallery
- [ ] Gallery заполнена (4-6 изображений)
- [ ] Каждое изображение с подписью (caption)
- [ ] Изображения показывают разные аспекты мода

#### GitHub
- [ ] README.md с описанием, скриншотами, инструкцией по сборке
- [ ] CHANGELOG.md (v1.0.0)
- [ ] LICENSE файл
- [ ] .gitignore актуален (нет build/, .gradle/, .idea/)

#### Финальная проверка
- [ ] Страница прочитана «свежими глазами» — за 10 секунд понятно что делает мод?
- [ ] Все ссылки работают (Modrinth, GitHub, wiki)
- [ ] Нет грамматических ошибок в описании
- [ ] `./gradlew build` — SUCCESS
- [ ] Jar файл тестирован в чистом инстансе (без dev-зависимостей)

### 13.12 — Тестирование совместимости с популярными модами ✅ DONE

Проверено в ходе тестирования. Критичный конфликт с Lithium обнаружен и решён Observer-подходом (13.13).

**Минимальный набор для тестирования:**

| Мод | Почему важен | На что смотреть |
|-----|-------------|-----------------|
| **Sodium** | Рендер-мод #1, меняет pipeline | FPS, корректность overlay |
| **Lithium** | Оптимизация серверной логики, в т.ч. хопперов | ✅ Совместимость подтверждена (Observer-подход, mixin удалён) |
| **Iris** | Шейдеры поверх Sodium | Overlay видимость, z-order |
| **Mod Menu** | Уже интегрирован, но проверить | Config screen, иконка |
| **Inventory Profiles Next** | Добавляет кнопки в GUI контейнеров | Позиционный конфликт с кнопкой IFM, наложение UI элементов |
| **REI / EMI** | Recipe viewers, добавляют панели в GUI | Перекрытие панели IFM, клик-зоны |

**Тест для каждого мода:**
1. Установить мод + IFM → игра запускается без крашей.
2. Открыть сундук → кнопка IFM на месте, не перекрыта другими элементами.
3. Открыть панель IFM → панель не конфликтует с UI другого мода.
4. Активный трекер → overlay отображается корректно.
5. Для Lithium: ✅ Решено Observer-подходом (13.13).

**Lithium — решено:** Observer-подход заменил mixin. Совместимость подтверждена.

### 13.13 — Observer-подход для Lithium-совместимости ✅ DONE

Lithium обходил `addItem()`, mixin не срабатывал. Решение: **сравнение содержимого контейнера каждый тик** через `ContainerObserver`.

**Преимущества:** работает с Lithium и любыми модами; ловит все источники предметов; не зависит от внутренней реализации Minecraft.

**Реализация:**
- `tracker/ContainerObserver.java` — `Map<BlockPos, SlotSnapshot[]>`, сравнение слотов каждый тик, запись положительных дельт
- Интегрирован в `TrackerNetworking.tick()` до обработки viewer'ов
- `mixin/HopperBlockEntityMixin.java` удалён, `itemflowmonitor.mixins.json` — пустой массив

**Тест:** ✅ Работает с Lithium и без. Хопперы, ручная вставка — всё трекается.

---

## Этап 14: Дополнительные фичи (Quality of Life)

### 14.1 — Копирование rate в чат по Shift+клик

По `Shift+клик` на overlay rate — скопировать текущее значение в чат как client-side сообщение (видно только игроку, не отправляется на сервер).

**Формат:**
- Режим конкретного предмета: `[IFM] Iron Ingot: 127/min`
- Режим All: `[IFM] All Items: 127/min`
- С учётом форматирования больших чисел (если 11.2 реализовано): `[IFM] Iron Ingot: 1.2K/hr`

**Реализация:**
- Определить клик-зону overlay (иконка + текст rate).
- При `Shift+клик` — `Minecraft.getInstance().gui.getChat().addMessage(Component.literal(...))` или `player.displayClientMessage(...)`.
- Визуальный фидбек: кратковременное мигание overlay (или звук UI click).

**Файлы:** `ItemFlowMonitorClient.java` — обработка клика в `renderRateOverlay()` или отдельный `mouseClicked` handler. Lang-файлы — формат сообщения (если нужен translatable prefix).

**Тест:**
1. Активный трекер с rate > 0 → Shift+клик на overlay → в чате сообщение `[IFM] Iron Ingot: 150/min`.
2. Режим All → `[IFM] All Items: 150/min`.
3. Без Shift → обычный клик, ничего не происходит.
4. Rate == 0 → `[IFM] Iron Ingot: 0/min`.

---

## Архитектура (итог)

### Файловая структура (целевая)
```
src/main/java/com/itemflowmonitor/
├── ItemFlowMonitor.java            — точка входа, команды, события
├── RateMode.java                   — enum: AVERAGE, ACTUAL, PREDICTED
├── TrackingMode.java               — enum: ALL, AUTO, MANUAL
├── TrackingPeriod.java             — enum: SECOND, MINUTE, HOUR
├── mixin/                          — (пусто, mixin удалён)
├── network/
│   ├── TrackerConfigC2SPacket.java — C2S пакет настроек
│   ├── TrackerUpdateS2CPacket.java — S2C пакет обновления
│   └── TrackerNetworking.java      — регистрация, обработка, тик
├── tracker/
│   ├── ContainerObserver.java      — observer: сравнение слотов каждый тик
│   ├── ContainerTracker.java       — логика трекера (events, rate, EMA)
│   ├── TrackerManager.java         — синглтон-реестр трекеров
│   └── TrackerSavedData.java       — сериализация (Codec)
└── util/
    └── ChestUtil.java              — нормализация двойных сундуков

src/client/java/com/itemflowmonitor/
├── ItemFlowMonitorClient.java      — клиентский entrypoint, UI, keybinding
├── client/
│   ├── SettingsPanel.java          — виджет панели настроек + тултипы
│   └── TrackerClientState.java     — клиентский кеш данных
└── config/
    ├── IFMConfig.java              — модель конфига + JSON I/O
    ├── IFMConfigScreen.java        — экран настроек (custom Screen)
    └── ModMenuIntegration.java     — Mod Menu API интеграция

src/main/resources/assets/itemflowmonitor/
├── icon.png                        — иконка мода 128×128
└── lang/
    ├── en_us.json                  — English (базовый)
    ├── ru_ru.json                  — Русский
    ├── zh_cn.json                  — 简体中文
    ├── zh_tw.json                  — 繁體中文
    ├── de_de.json                  — Deutsch
    ├── fr_fr.json                  — Français
    ├── es_es.json                  — Español
    ├── pt_br.json                  — Português (Brasil)
    ├── ja_jp.json                  — 日本語
    ├── ko_kr.json                  — 한국어
    ├── uk_ua.json                  — Українська
    └── pl_pl.json                  — Polski
```

### Общие требования к коду

- **Язык:** Java 21
- **Модлоадер:** Fabric (Fabric API)
- **Без новых блоков** — только Observer + GUI (серверные Mixin удалены в 13.13)
- **Серверная + клиентская часть** — трекинг на сервере, отображение на клиенте, связь через custom networking
- **Минимальное влияние на производительность** — кольцевой буфер с ограниченным размером, события записываются только если трекер активен для данного контейнера
- **Логирование** — ключевые события (создание/удаление трекера, запись события) логируются на уровне DEBUG
